<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://singledigit9.github.io</id>
    <title>资料库</title>
    <updated>2020-07-31T06:11:56.060Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://singledigit9.github.io"/>
    <link rel="self" href="https://singledigit9.github.io/atom.xml"/>
    <subtitle>One By One</subtitle>
    <logo>https://singledigit9.github.io/images/avatar.png</logo>
    <icon>https://singledigit9.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 资料库</rights>
    <entry>
        <title type="html"><![CDATA[《游戏设计模式》读书笔记——序列模式]]></title>
        <id>https://singledigit9.github.io/post/lesslessyou-xi-she-ji-mo-shi-greatergreater-du-shu-bi-ji-xu-lie-mo-shi/</id>
        <link href="https://singledigit9.github.io/post/lesslessyou-xi-she-ji-mo-shi-greatergreater-du-shu-bi-ji-xu-lie-mo-shi/">
        </link>
        <updated>2020-07-31T05:53:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1>
<p>这部分主要是介绍了一些游戏中有关时序之类的设计模式。现在的引擎封装的都很好，基本上用不到这些。<br>
但还是需要做一些了解，万一有需求需要的话知道大概该怎么做。</p>
<h1 id="双缓冲模式">双缓冲模式</h1>
<h2 id="个人理解">个人理解</h2>
<p>为了解决不同线程见访问同一块内存数据，有可能获取到错误数据的问题。<br>
但对内存苛刻的设备上就不好用这个了。</p>
<h2 id="简单描述">简单描述</h2>
<p>保存了下一个缓冲和当前缓冲。读取始终从当前缓冲读取。写入都写入下一个缓冲，写入完毕后将下一个缓冲和当前缓冲进行交换。</p>
<h2 id="注意事项">注意事项</h2>
<ol>
<li>双缓冲模式是位于底层的，外部不应该接触到双缓冲的内部逻辑</li>
<li>两个缓冲交换是需要一定时间的，一般是直接交换指针（引用）。如果交换的时间过长，那么双缓冲就失去意义了。</li>
<li>需要注意浅复制，不要让外部的代码存储对双缓冲的永久引用。</li>
</ol>
<h1 id="游戏循环">游戏循环</h1>
<h2 id="定义">定义</h2>
<p>游戏循环在游戏运行过程中不断运行。每次循环，都能够无阻塞的处理玩家输入，更新游戏状态，渲染状态。并且能够控制游戏速度。</p>
<h2 id="其他">其他</h2>
<p>每一帧中处理的数据不要过大，不然会影响游戏的运行速度。</p>
<h1 id="更新方法">更新方法</h1>
<h2 id="定义-2">定义</h2>
<p>每个对象实现一个更新方法来模拟当前对象在这一帧中的行为状态。</p>
<h2 id="个人理解-2">个人理解</h2>
<p>这个东西就比较常用了，Unity中的Update和自己平时写的其他的好多代码都用到了这个东西。还是尽可能让对象自己管自己的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《游戏编程模式》读书笔记——基础设计模式]]></title>
        <id>https://singledigit9.github.io/post/lesslessyou-xi-bian-cheng-mo-shi-greatergreater-du-shu-bi-ji-ji-chu-she-ji-mo-shi/</id>
        <link href="https://singledigit9.github.io/post/lesslessyou-xi-bian-cheng-mo-shi-greatergreater-du-shu-bi-ji-ji-chu-she-ji-mo-shi/">
        </link>
        <updated>2020-07-30T03:05:58.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="写在前面">写在前面</h1>
<p>这本书是半个月前开始看的吧，主要是觉得作者是一个资深的游戏开发，有些设计模式的东西游戏确实和其他的一些应用软件不一样，看下来应该会有所收获。<br>
此外个人觉得，设计模式这个东西，不在于死记硬背生搬硬套。而在于当遇到某个问题的时候，设计模式能够给你一个原始的思路，使你的代码实现能够尽可能满足需求和未来可能的变化。<br>
ps. 这些设计模式是在新模块制作的时候用的，一般写业务逻辑大概率用不上，注意可复用的逻辑代码和表现代码分离就好了。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1>
<p>这本书是半个月前开始看的吧，主要是觉得作者是一个资深的游戏开发，有些设计模式的东西游戏确实和其他的一些应用软件不一样，看下来应该会有所收获。<br>
此外个人觉得，设计模式这个东西，不在于死记硬背生搬硬套。而在于当遇到某个问题的时候，设计模式能够给你一个原始的思路，使你的代码实现能够尽可能满足需求和未来可能的变化。<br>
ps. 这些设计模式是在新模块制作的时候用的，一般写业务逻辑大概率用不上，注意可复用的逻辑代码和表现代码分离就好了。</p>
<!-- more -->
<h1 id="命令模式">命令模式</h1>
<h2 id="个人理解">个人理解</h2>
<p>就是将要执行的具体行为进行封装，交由想执行这个行为的角色执行，而不是直接执行。</p>
<h2 id="优点">优点</h2>
<p>将具体的行为进行封装，从而使目标和目标的行为进行分离，方便对目标行为进行扩展。</p>
<h2 id="能够做什么">能够做什么</h2>
<ol>
<li>输入系统</li>
<li>AI系统（和输入系统一样，只不过触发方式变了一下）</li>
<li>能够方便的进行撤销操作。（每个Command实现撤销方法，然后使用List记录Command顺序）</li>
<li>回放系统。</li>
</ol>
<h1 id="原型模式">原型模式</h1>
<p>这个书里面讲的感觉不是很好，绕晕了。</p>
<h2 id="个人理解-2">个人理解</h2>
<p>每个对象实现自己的clone方法，然后使用获取器对缓存的对象进行<strong>复制</strong>。</p>
<h2 id="与工厂模式的区别">与工厂模式的区别</h2>
<p>工厂模式直接<code>new</code>对象，并对它进行初始化设置。<br>
原型模式直接使用已经有的对象进行<strong>复制</strong>。<br>
一个是创建，一个是复制。</p>
<h2 id="适用范围">适用范围</h2>
<p>大对象的创建。大的对象往往复制会比创建更快。</p>
<h1 id="状态模式">状态模式</h1>
<h2 id="优点-2">优点</h2>
<p>状态模式将各种不同状态的操作进行隔离，避免大量的标记量和if判断。</p>
<h2 id="包含内容">包含内容</h2>
<p>状态Node的进入，离开，触发，以及当前Node可以去的Node。（Node的图的连接方向，这个之前自己写的东西没有弄这个）</p>
<h2 id="有限状态机">有限状态机</h2>
<ol>
<li>预先知道所有状态的集合</li>
<li>同一时间只能有一个状态</li>
<li>Node核心要素：
<ol>
<li>状态：</li>
<li>输入：对外部输入作出反应，比如执行纯逻辑，或者切换状态什么的</li>
<li>转移：知道自己能够切换到哪个Node上去</li>
</ol>
</li>
</ol>
<h2 id="分层状态机">分层状态机</h2>
<p>状态机中的Node使用继承。当前Node如果处理不了当前状态的话，将处理丢给父类。</p>
<h2 id="下推状态机">下推状态机</h2>
<p>将有限状态机中的当前状态的保存换为一个栈，这样当当前栈顶的状态执行完毕后，可以恢复到上一个状态。（实际上就是额外增加了一个记录）</p>
<h2 id="个人理解-3">个人理解</h2>
<p>状态模式这个东西用的很多了。一般情况下，有限状态机足够用了。其余的有些奇奇怪怪需求的稍微变种一下就可以。</p>
<h1 id="享元模式">享元模式</h1>
<ol>
<li>享元模式不是什么简单的对象池，而是多个对象共享相同的一个对象数据。</li>
<li>通过共享部分数据，减少数据的创建和数据的冗余。</li>
</ol>
<h1 id="观察者模式">观察者模式</h1>
<ol>
<li>这个粗暴些描述就是C#中的event。平时总是各种用，就不再细写了。</li>
<li>需要注意的就是注册过后要及时解注册，不然可能会有一些对象因为异常引用而无法释放。</li>
</ol>
<h1 id="单例模式">单例模式</h1>
<h2 id="使用单例模式的原因">使用单例模式的原因</h2>
<ol>
<li>没被使用时，不用初始化创建对象。</li>
<li>运行时初始化，可以控制初始化顺序。</li>
<li>可以使用可继承单例来实现一些特殊功能。比如不同平台的加载系统Log系统。</li>
</ol>
<h2 id="不使用单例的原因">不使用单例的原因</h2>
<ol>
<li>增加理解代码的难度。
<ol>
<li><strong>只使用局部变量的函数叫纯函数，纯函数往往利于理解，利于编译器优化。</strong></li>
<li>如果使用了全局变量，一旦因为全局变量出现了Bug，那么你就得在几十上百个引用中查找究竟是哪一个引用导致了全局变量的错误。</li>
</ol>
</li>
<li>增加代码耦合的可能性。做新功能的时候，往往会因为代码不熟悉或者想懒得动手动脑而采取最简单的方式来做东西。但这种情况下，单例模式因为提供了全局的访问接口，所以可以在各个系统中进行访问，从而导致一些不该有依赖关系的系统产生依赖关系。
<ol>
<li>比如《群星守卫》中，Server数据处理的位置有些地方和界面耦合，严谨些写的话应该拆开的。比如HandleServerMsg里面调用两个函数，一个HandleServerData，一个HandleServerView。不过毕竟还是少，这么写还算能够理解。</li>
</ol>
</li>
<li>对并行不友好。</li>
</ol>
<h2 id="单例的问题所在">单例的问题所在</h2>
<ol>
<li>存在唯一的实例和对所有人开方访问是两个完全不相关的问题。但单例把这两个强行绑定了。</li>
<li>延迟创建确实用起来很方便，但也某种意义上让我们丧失了对单例对象的创建的控制。</li>
</ol>
<h2 id="避免滥用单例的方法">避免滥用单例的方法</h2>
<ol>
<li>去除没有必要的管理类。数量过多的管理类只能说明作者对oop不够熟悉。<strong>oop的核心就是让对象自己管好自己</strong>。</li>
<li>可使用<code>assert</code>之类的断言来防止多个创建。（不该多个创建的地方多个创建了，说明这块使用的有问题，有问题就应该直接报错，暴露出来解决掉。）</li>
<li>将对象作为参数传进来。</li>
<li>将对象的访问从基类进行继承。</li>
<li>让不能避免的全局入口携带对象。（这个看个人习惯，不能完全照搬）</li>
</ol>
<h2 id="个人感想">个人感想</h2>
<p>单例一样特别常用，但说实话，我个人并不喜欢。<br>
游戏中的单例往往都是游戏初始化时创建，然后游戏结束销毁。<br>
但既然它全局存在，为啥不用静态类呢？写代码的时候少敲一个GetInstance不舒服么？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++视频学习笔记（一）]]></title>
        <id>https://singledigit9.github.io/post/cshi-pin-xue-xi-bi-ji-yi/</id>
        <link href="https://singledigit9.github.io/post/cshi-pin-xue-xi-bi-ji-yi/">
        </link>
        <updated>2020-07-15T18:03:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="视频1为什么要学c">视频1：为什么要学C++</h1>
<ol>
<li>高效（在代码不烂的基础上）</li>
<li>能够控制底层硬件</li>
<li>任意平台支持</li>
<li>能够控制CPU执行的任意一条指令</li>
</ol>
<h1 id="视频234c编程环境配置">视频2，3，4：C++编程环境配置</h1>
<p>C++编程环境配置以及Hello World</p>
<h1 id="视频5c如何工作的">视频5：C++如何工作的</h1>
<ol>
<li>流程：C++代码 =[编译]=》一个C++文件对应一个obj文件 =[链接器]=》exe，dll等等。</li>
<li>Build过程中注意Debug/Release设置和目标平台的设置。</li>
<li>不同平台的Debug/Release可以单独设置，注意打包时不要弄错。</li>
<li>默认Debug设置下，有个配置选项不是速度优先，所以一般Debug模式下代码都比较慢</li>
<li>看报错Log时不要只看提示，应该看完整的Log。那个提示只是在Log中抓取error关键字进行显示而已。</li>
<li>链接器会找不同文件中代码的各种引用定义，来确定各个文件代码中使用的时正确的引用。</li>
</ol>
<h1 id="视频6编译器如何工作">视频6：编译器如何工作</h1>
<ol>
<li>将文本文件转化为可执行文件需要两个步骤：编译和链接</li>
<li>编译器的主要工作就是将文本文件转化为Obj文件
<ol>
<li>预处理文件，执行预编译指令。（include只是简单的把别的文件的代码粘贴到当前的代码中）</li>
<li>标记解释【<strong>这个地方记不太清了需要重新看一下</strong>】</li>
<li>解析</li>
</ol>
</li>
<li>每一个Cpp文件都是一个编译单元。</li>
<li>C++不在乎文件，文件只是给编译器提供原始代码数据的一种方式，可以指定任意后缀的文件作为源代码文件。</li>
<li>编译单元不等于cpp文件，因为cpp文件中可能会相互相互include。【<strong>这一个部分需要进一步测试，理解不好</strong>】</li>
<li>可以设置配置，生成预处理后的代码文件（xxx.i）</li>
<li>可以配置，让生成的Obj改为其他的可读模式</li>
<li>Debug模式，编译器会插入许多代码来帮助Debug</li>
<li>Obj的可读模式中，函数名会编程一系列编码，因为程序需要各种函数是唯一的。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《暴雪的哈希算法》笔记]]></title>
        <id>https://singledigit9.github.io/post/lesslessbao-xue-de-ha-xi-suan-fa-greatergreater-bi-ji/</id>
        <link href="https://singledigit9.github.io/post/lesslessbao-xue-de-ha-xi-suan-fa-greatergreater-bi-ji/">
        </link>
        <updated>2020-06-30T14:48:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>今天看了《暴雪的哈希算法》这篇文章。<br>
虽然说哈希算法基本都是老生常谈，但文章中哈希的实现思路确实很巧妙，很值得借鉴。</p>
<h1 id="特别之处">特别之处</h1>
<p>相比于一般的哈希算法，计算一次哈希值，之后冲突时或者使用链表，或者下移。<br>
暴雪的哈希算法计算了三个哈希值，从概率上来看，两个字符串的三个哈希值都一样的概率非常非常低，可以忽略这种情况。<br>
至于查找时，通过依次比对字符串3个哈希值来确定当前哈希表中是不是有该值，效率更高。</p>
<h1 id="文章链接">文章链接</h1>
<p>https://www.cnblogs.com/duzouzhe/archive/2009/10/14/1583359.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《游戏编程模式》读书笔记 序章]]></title>
        <id>https://singledigit9.github.io/post/lesslessyou-xi-bian-cheng-mo-shi-greatergreater-du-shu-bi-ji-xu-zhang/</id>
        <link href="https://singledigit9.github.io/post/lesslessyou-xi-bian-cheng-mo-shi-greatergreater-du-shu-bi-ji-xu-zhang/">
        </link>
        <updated>2020-06-27T14:36:50.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="写在前面">写在前面</h1>
<p>书的英文名是《Game Programming Patterns》，作者是Robert Nystrom。<br>
看了序章的内容，就觉得这本书和一般的设计模式书相比，更加贴近于游戏开发。而且序章中明确的指出了一些开发过程中可能遇到的问题。<br>
对于游戏开发的帮助很大。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1>
<p>书的英文名是《Game Programming Patterns》，作者是Robert Nystrom。<br>
看了序章的内容，就觉得这本书和一般的设计模式书相比，更加贴近于游戏开发。而且序章中明确的指出了一些开发过程中可能遇到的问题。<br>
对于游戏开发的帮助很大。</p>
<!-- more -->
<h1 id="游戏开发中常见的挑战">游戏开发中常见的挑战</h1>
<ol>
<li>时间和顺序。</li>
<li>高度压缩的开发周期，高速的版本迭代。需要程序能够快速迭代版本同时保证<strong>不干扰他人</strong>，<strong>不污染代码库</strong>。</li>
<li>实现互动不能把代码搞的一团糟。比如怪物攻击英雄，炸弹炸飞敌人之类的。</li>
<li>性能很重要。</li>
</ol>
<h1 id="怎么评价一个架构的好坏">怎么评价一个架构的好坏</h1>
<ol>
<li>架构是有关于改动的，没有改动的情况下谈架构毫无意义。</li>
<li>评价架构的好坏就是它对应改动有多么轻松。</li>
</ol>
<h1 id="解耦的根本目的是什么">解耦的根本目的是什么</h1>
<p>扩展新功能时，总是要把对应的模块代码熟悉好，知道什么地方是干什么的。<br>
解耦的作用就在于，<strong>最小化在编码前需要了解的信息</strong>。<br>
另一个常规的解耦的作用就是，当一块代码有改动时，没必要改动另一块代码。<strong>耦合度越小，改动所波及的外围就越小</strong>。</p>
<h1 id="架构的代价">架构的代价</h1>
<ol>
<li><strong>需要汗水和纪律来维持好的设计</strong>。需要每一次功能实现和改动都努力去保持架构原有的结构。</li>
<li><strong>需要管理代码</strong>。有无数优雅的开始，死于懒得动脑的“黑魔法”。</li>
</ol>
<h1 id="警惕过度设计">警惕过度设计</h1>
<p>当你在不怎么确定的功能实现的过程中，添加了抽象可扩展之类的支持，你是在赌需求和你预留的扩展一致。此外，抽象和扩展需要不断的进行维护。</p>
<p>当你过分关注抽象和扩展之类的东西，你写的代码就失控了——抽象和接口无处不在——最终可能你自己都不知道实现这个功能需要用什么接口，也有可能出现一个莫名奇妙的Bug让你查上一整天。</p>
<h1 id="性能和速度">性能和速度</h1>
<p>架构使代码变得灵活，灵活性让我们能够更快速的改进游戏，高速迭代。但也可能会加大运行时的开销。</p>
<p>性能与假设相关，<strong>确定性能优化方案需要有明确的需求限制</strong>。在需求不明确的情况下，你做的优化很有可能是无效优化甚至是负面优化（出了Bug或者不能满足功能）。</p>
<p>一种折中的方案就是保持代码灵活性，直到确定设计，再去除多余抽象等来提高性能。</p>
<h1 id="关于速度的权衡">关于速度的权衡</h1>
<p>长期开发速度，游戏运行速度，短期开发速度。这三者基本上是相互对立的，没有正确的方案，只有当前下的最优解。这个最优解取决于很多放面的因素，包括团队风格，领导风格，工作流程等等。</p>
<h1 id="简单">简单</h1>
<p>这个简单指的就是你的代码要尽可能的简单，让人能够简单明了的知道你写的每一个函数，每一个类都是干什么的。<br>
最最直观的就是代码量要尽可能的小，该有注释的地方不要省注释。</p>
<p>代码简单少，意味着写新功能需要提前读的代码少，查Bug读的代码也少，也因为代码少能避免很多不必要的Bug。</p>
<p><em>曾经在开发过程中遇到过这样的代码，他把数据类中的数据在自己功能实现的地方做了多次额外缓存， 最终导致的后果就是，数据更新的地方出了Bug，各种缓存数据需有的需要立即更新，有的需要延迟更新，代码乱到基本无法维护，只能重写。</em></p>
<h1 id="最后的建议">最后的建议</h1>
<ol>
<li>抽象和解耦让代码更容扩展，但除非确认需要灵活性，否则不用在这个上面浪费时间。</li>
<li>整个开发过程中确实需要考虑设计，但要避免针对底层的大面积优化。因为这样做会锁死代码，导致自己或者其他人无法进行正常的开发流程。</li>
<li>确定要被抛弃的代码用不着搞的尽善尽美。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SimpleFramework的相关文档]]></title>
        <id>https://singledigit9.github.io/post/simpleframework-de-xiang-guan-wen-dang/</id>
        <link href="https://singledigit9.github.io/post/simpleframework-de-xiang-guan-wen-dang/">
        </link>
        <updated>2020-06-06T09:37:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>这个框架算是为了总结自己所掌握的东西的一个总结。目标是基于Unity和FairyGUI，完成一个轻量的方便使用的游戏框架。<br>
目前完成了一部分，还有不少内容需要填充和测试，空闲时间一点一点来做吧。</p>
<h2 id="碎碎念">碎碎念</h2>
<p>其实之前自己也写过一些半残的东西，不过很多都不成体系，模块不全。此外也是深感自己在技术学习上有种<strong>N乘50%<strong>的感觉，想总体回顾一下，把欠缺的东西补到</strong>100%</strong>。<br>
这个文档主要是记录自己已经完成了什么，完成的部分该怎么使用。以及还没有完成什么，已经完成的部分有哪些优化空间；以及一些临时想到的可以做的编辑器工具等等。<br>
希望今年年底能够完成所有主体功能，且都测试过，也就是传说中的1.0版本。</p>
<h1 id="已完成测试">已完成测试</h1>
<h2 id="对象池">对象池</h2>
<h2 id="状态机">状态机</h2>
<h2 id="事件系统">事件系统</h2>
<h2 id="调试工具部分">调试工具[部分]</h2>
<h3 id="有log输出工具">有Log输出工具</h3>
<h3 id="输出运行时间类">输出运行时间类</h3>
<h1 id="完成未测试">完成未测试</h1>
<h2 id="配置表">配置表</h2>
<ol>
<li>数据读取存储[完成]</li>
<li>自动生成代码[完成]</li>
<li>生成序列化数据[完成]</li>
<li>生成代码序列化数据配置工具[完成]</li>
<li>PC/Android/Ios各个平台测试[未完成]</li>
<li>测试[未完成]</li>
</ol>
<h1 id="进行中">进行中</h1>
<h2 id="ui">UI</h2>
<ol>
<li>界面生命周期[部分]
<ol>
<li>初始化</li>
<li>enter动画</li>
<li>显示界面</li>
<li>exit动画</li>
<li>隐藏界面</li>
<li>销毁界面</li>
</ol>
</li>
<li>界面切换缓存策略[未完成]</li>
<li>红点系统[部分]</li>
<li>强制引导系统[未完成]</li>
</ol>
<h2 id="assetbundle">AssetBundle</h2>
<ol>
<li>打AssetBundle工具[部分]
<ol>
<li>选定哪些资源打到哪个Bundle里面</li>
<li>Bundle的一些配置</li>
</ol>
</li>
<li>依赖查询工具[部分]</li>
<li>生成AssetBundle的加密和解密[未]</li>
</ol>
<h2 id="资源加载">资源加载</h2>
<ol>
<li>AssetBundle加载[未]
<ol>
<li>LZMA压缩模式</li>
<li>LZ4和未压缩模式</li>
</ol>
</li>
<li>Resources加载[未]</li>
<li>编辑器下模拟AssetBundle加载[未]</li>
<li>冗余缓存的清理[未]</li>
</ol>
<p>#未开始</p>
<h2 id="启动流程">启动流程</h2>
<h2 id="网络部分">网络部分</h2>
<ol>
<li>HTTP连接</li>
<li>TCP连接</li>
<li>UDP连接</li>
</ol>
<h2 id="本地数据保存加载">本地数据保存加载</h2>
<h2 id="本地化">本地化</h2>
<h2 id="常用的shader效果">常用的Shader效果</h2>
<h2 id="其他插件工具">其他插件工具</h2>
<ol>
<li>摇杆（这个应该有插件，找个好用的集成进来）</li>
</ol>
<h2 id="其他编辑器工具这部分工具随时想到随时添加">其他编辑器工具（这部分工具随时想到随时添加）</h2>
<ol>
<li>噪声图生成工具</li>
<li>渐变采样图生成工具</li>
<li>随机地形生成工具</li>
<li>随机地牢生成工具</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[表面着色器中的结构体]]></title>
        <id>https://singledigit9.github.io/post/biao-mian-zhao-se-qi-zhong-de-jie-gou-ti/</id>
        <link href="https://singledigit9.github.io/post/biao-mian-zhao-se-qi-zhong-de-jie-gou-ti/">
        </link>
        <updated>2020-05-30T14:27:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="input">Input</h1>
<figure data-type="image" tabindex="1"><img src="https://singledigit9.github.io/post-images/1590848930611.jpeg" alt="" loading="lazy"></figure>
<h1 id="surfaceoutput">SurfaceOutPut</h1>
<p><img src="https://singledigit9.github.io/post-images/1590849021066.jpeg" alt="" loading="lazy"><br>
<img src="https://singledigit9.github.io/post-images/1590849027972.jpeg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Unity Shader 入门精要》读书笔记（扩展篇）]]></title>
        <id>https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-kuo-zhan-pian/</id>
        <link href="https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-kuo-zhan-pian/">
        </link>
        <updated>2020-05-19T18:18:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第17章-unity表面着色器探秘">第17章 Unity表面着色器探秘</h1>
<ol>
<li>表面着色器，实际上是Unity在基本的顶点片元着色器上进行的一次封装。在实际运行过程中，会自动转换成对应的顶点片元着色器来运行。</li>
<li>表面着色器的好处在于，可以方便的处理光照等效果。相同的光照效果用表面着色器实现，需要写的代码会比顶点片元着色器少好多。但它的缺点在于，一是自由度受到一些限制，有些特殊效果表面着色器实现不了；二是性能消耗一般都比较大。</li>
<li>表面着色器的计算步骤
<ol>
<li>将CGPROGRAM和ENDCG中的代码进行复制</li>
<li>生成顶点着色器输出结构体v2f_surf，用于顶点着色器和片元着色器之间数据传递。</li>
<li>生成顶点着色器。</li>
<li>生成片元着色器。</li>
<li>颜色叠加。</li>
<li>最后的颜色修改函数。<br>
<img src="https://singledigit9.github.io/post-images/1590849115208.jpeg" alt="" loading="lazy"></li>
</ol>
</li>
</ol>
<h1 id="第18章-基于物理的渲染">第18章 基于物理的渲染</h1>
<ol>
<li>Unity的Standard是金属工作流，Specularsetup是高光反射工作流。两种Shader都能调出相同的效果，只是有些参数不一样。</li>
<li>伽马校正：
<ol>
<li>原理是人们对明亮部分的光线变化的敏感程度远远低于暗的部分的敏感程度。比如，一个房间开一盏灯到开两盏灯和开99盏灯到开100盏灯给人的感觉是不同的。</li>
<li>伽马矫正是为了更加充分的利用图像的存储空间，将不明显的明亮部分压缩，将变化明显的暗的部分放大以存储更精细的值。</li>
<li>伽马校正下，显示整体偏暗。</li>
</ol>
</li>
<li>PBS（基于物理的渲染）优点在于，相当大的一部分物体，可以使用同一套shader来进行渲染，而且不用各种调参。缺点在于使用起来比较复杂，而且消耗来说也比较高。</li>
</ol>
<h1 id="第19章-unity5更新了什么">第19章 Unity5更新了什么</h1>
<p>现在版本都2019了，这章好多东西应该都不适用了，更详细的应该查unity的更新文档了。但还是简单记录一下，万一遇到类似的问题能够快速反应过来。</p>
<ol>
<li>表面着色器报错。
<ol>
<li>通常是因为转换着色器时使用了一些额外的效果计算，比如法线，光照之类的。从而导致需求的寄存器数目超过限定的寄存器数目。</li>
<li>解决办法
<ol>
<li>可以将默认的Shader Model 2.0 改为3.0，即<code>#pragma target 3.0</code>。</li>
<li>可以手动设置该着色器不计算阴影纹理坐标（不接受阴影），不计算光照纹理和雾效 ，减少额外计算。即<code>#pragma surface surfaceFunction lightModeln oshadow nolightmap nofog</code></li>
</ol>
</li>
</ol>
</li>
<li>CPU不再处理非统一缩放，也就是说，CPU会把顶点信息和非统一缩放的矩阵直接传给Shader。因此在顶点片元着色器中变换顶点法线时，需要注意非统一缩放的影响，也要注意对变换后的法线进行手动归一化操作。</li>
<li>固定管线Shader被放弃。</li>
</ol>
<h1 id="第20章-还有更多内容么">第20章 还有更多内容么</h1>
<ol>
<li>OpenGL
<ol>
<li>红宝书：《OpenGL编程指南》</li>
<li>蓝宝书：《OpenGL超级宝典》</li>
</ol>
</li>
<li>GPU精粹系列</li>
<li>叶劲峰 ，计算机图形：入门/API类；Gems类</li>
<li>GPU Pro系列和ShaderX系列</li>
<li>物理渲染和光线追踪：《Physically based rendering : From theory to implementation》</li>
<li>学术会议（Ke-Sen Huang主页上有历年的论文）
<ol>
<li>SIGGRAPH</li>
<li>SIGGRAPH Asia</li>
<li>Eurographics</li>
<li>Symposium On Interactive 3D Graphics And Games</li>
</ol>
</li>
<li>Shadertoy网站</li>
<li>GLSL SandBox Gallery网站</li>
</ol>
<h1 id="后记">后记</h1>
<p>算是终于完整看完了一遍吧。感觉自己对着色器这块确实了解的更加深入了。有一些以前一知半解的东西知道是怎么回事了。比如说伽马空间之类的。<br>
此外就是觉得自己做的练习还是比较少，而且仅仅是记笔记的话也不是很方便以后自己翻笔记查阅。因此准备在gitbook上专门弄一个shader的资料库。算是复习和继续深入学习兼而有之吧。<br>
预备Shader资料库的大致结构分为基础知识部分，数学部分，算法公式部分，代码块部分，各种常见效果和自我研究的效果的实例部分。<br>
内容很多，希望能够在今年内把基本的内容填充完毕吧。<br>
也希望资料库完成后能给自己和其他需要的同学提供帮助。<br>
--2020.05.30 23:13</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Unity Shader入门精要》读书笔记（高级篇）]]></title>
        <id>https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-gao-ji-pian/</id>
        <link href="https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-gao-ji-pian/">
        </link>
        <updated>2020-05-16T15:22:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第12章-屏幕后处理效果">第12章 屏幕后处理效果</h1>
<h2 id="脚本api">脚本API</h2>
<ol>
<li>相机脚本中使用的API</li>
</ol>
<pre><code class="language-c_sharp">Monobehavior.OnRenderImage(RenderTexture src, RenderTexture dest){}

Graphics.Blit(Texture src, RenderTexture dest);
Graphics.Blit(Texture src, RenderTexture dest,  Material mat, int pass =  -1);
Graphics.Blit(Texture src, Material mat, int pass = -1);
</code></pre>
<ol start="2">
<li>参数说明
<ol>
<li>src：源纹理</li>
<li>mat：使用的材质</li>
<li>dest：目标渲染纹理。为Null则直接将结果显示在屏幕上</li>
<li>pass：默认-1，表示会依次执行Shader中所有的Pass，否则只执行指定索引的Pass</li>
</ol>
</li>
<li><code>ImageEffectOpaque</code>：可以控制OnRenderImage执行的位置。比如当只想后处理不透明物体时，设置这个属性，使OnRenderIamge在不透明物体渲染完毕后立即调用。</li>
</ol>
<h2 id="应用">应用</h2>
<ul>
<li>屏幕后处理的标配 <code>ZTest Always Cull Off ZWrite Off</code></li>
</ul>
<h3 id="调节屏幕亮度饱和度和对比度">调节屏幕亮度，饱和度和对比度</h3>
<ol>
<li>亮度：颜色 * 亮度值</li>
<li>饱和度：</li>
</ol>
<pre><code class="language-shader">fixed4 color = tex2D(_MainTex, i.uv)
fixed temp = 0.2125 * color.r + 0.7154 * color.g + 0.0721  * color.b;
fixed tempColor = fixed(temp, temp, temp);
color = fixed4(lerp(tempColor, color.rgb, 饱和度值), color.a);
</code></pre>
<ol start="3">
<li>对比度：</li>
</ol>
<pre><code class="language-shader">color = (lerp(fixed3(0.5, 0.5, 0.5), color.rgb, 对比度值), color.a);
</code></pre>
<h3 id="边缘检测">边缘检测</h3>
<ol>
<li>常见的边缘检测算子<br>
<img src="https://singledigit9.github.io/post-images/1589705801787.jpeg" alt="" loading="lazy"></li>
<li>梯度计算
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><msqrt><mrow><msubsup><mi>G</mi><mi>x</mi><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>G</mi><mi>y</mi><mn>2</mn></msubsup></mrow></msqrt></mrow><annotation encoding="application/x-tex">G=\sqrt{G_x^2 + G_y^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.84em;vertical-align:-0.6765000000000001em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1635em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7401079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.1235em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.8800000000000001em;"><svg width='400em' height='1.8800000000000001em' viewBox='0 0 400000 1944' preserveAspectRatio='xMinYMin slice'><path d='M1001,80H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,
572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,
-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39
c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60
s208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,
-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5c4,-6.7,10,-10,18,-10z
M1001 80H400000v40H1013z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6765000000000001em;"><span></span></span></span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><mi mathvariant="normal">∣</mi><msub><mi>G</mi><mi>x</mi></msub><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><msub><mi>G</mi><mi>y</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">G = |G_x| + |G_y|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span></li>
</ol>
</li>
</ol>
<h3 id="高斯模糊">高斯模糊</h3>
<ol>
<li>高斯模糊卷积核<br>
<img src="https://singledigit9.github.io/post-images/1589706552526.jpeg" alt="" loading="lazy"></li>
<li><code>RenderTexture.GetTemporary</code>：获取一个缓存RenderTexture</li>
<li><code>RenderTexture.ReleaseTemporary</code>：释放缓存RenderTexture</li>
</ol>
<h3 id="bloom效果">Bloom效果</h3>
<ol>
<li>原理：根据阈值提取出较亮的区域，存在一个RenderTexture中，然后对它进行模糊，模拟光线扩散。最后将RenderTexture与原图向混合。</li>
<li>阈值提取</li>
</ol>
<pre><code class="language-shader">fixed luminance(fixed4 color) {
    return  0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b; 
}

fixed4 fragExtractBright(v2f i) : SV_Target {
    fixed4 c = tex2D(_MainTex, i.uv);
    fixed val = clamp(luminance(c) - _LuminanceThreshold, 0.0, 1.0);
    
    return c * val;
}
</code></pre>
<h3 id="运动模糊">运动模糊</h3>
<ol>
<li><code>RenderTexture.MarkRestoreExpected</code>：标记这个RenderTexture需要还原操作，避免Unity警告。</li>
<li>原理：
<ol>
<li>将多个图像进行叠加</li>
<li>使用速度缓存，根据速度来决定模糊采样的大小和方向</li>
</ol>
</li>
<li>书中使用的方法是在同一个RenderTexture上叠加图像来实现的。但速度过快时，会明显看到单帧的图像。</li>
</ol>
<h1 id="第13章-使用深度和法线纹理">第13章 使用深度和法线纹理</h1>
<ol>
<li>深度纹理本质上是一张渲染纹理，它存储的是深度值而不是颜色值。范围是 [0, 1]</li>
<li>深度值和NDC空间z坐标对应关系：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>=</mo><msub><mi>z</mi><mrow><mi>n</mi><mi>d</mi><mi>c</mi></mrow></msub><mo>∗</mo><mn>0.5</mn><mo>+</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">d =  z_{ndc} *  0.5 +  0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span></span></li>
<li>Unity得到深度纹理的流程
<ol>
<li>延迟渲染路径时，因为延迟渲染会把深度信息法线信息渲染都G-Buffer中，所以深度纹理和能够直接冲G-Buffer中获取，深度法线纹理一样简单合并一下就可以得到。</li>
<li>无法直接获取时，深度和法线纹理是通过单独的Pass来渲染获取的。Unity会使用<strong>着色器替换</strong>技术来选择那些渲染类型为<code>Opaque</code>的物体，判断它们的渲染队列是不是小于2500（包含BackGround，Geometry，AlphaTest），如果满足条件，则建起渲染到深度纹理中。因此，要想获得争取的深度纹理，就需要设置正确的<code>RenderType</code>。
<ol>
<li>Unity调用ShadowCaster的Pass来渲染深度纹理，因此，如果物体的Shader中不包含这个Pass，，那么这个物体就不会出现在深度纹理中。</li>
<li>Unity可以设置只渲染深度纹理还是渲染深度法线纹理。</li>
<li>因为前向渲染默认不创建深度缓存，所以Unity底层使用了额外的Pass来额外渲染。这个Pass在<code>/DefaultResources/Camera-DepthNormalTexture.shader</code>中。</li>
</ol>
</li>
</ol>
</li>
<li>深度纹理通常是24位或者16位。深度法线纹理通常是32位，其中法线存储在RG中，深度存储在BA中。</li>
<li>具体的获取
<ol>
<li>C#脚本中的API：<code>camera.depthTextureMode</code></li>
<li>Shader中声明的贴图：<code>_CameraDepthTexture</code>和<code>_CameraDepthNormalTexture</code>。</li>
<li>Shader中的采样
<ol>
<li>一般来说直接用tex2D就可以，但可能某些平台会不适用。</li>
<li>使用Unity内置的宏<code>float d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i,uv);</code></li>
<li>类似的还有<code>float d = SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(i.scrPos))</code>
<ol>
<li>第二个参数通常是由顶点着色器输出插值而得到的屏幕坐标。<code>i.scrPos = ComputeScreenPos(o.pos)</code></li>
<li>采样计算过程，使用前两个分量除以最后一个分量。</li>
</ol>
</li>
<li><code>DecodeDepthNormal(float4 depthNormalTexColor, out float depth, out float3 normal)</code>
<ol>
<li>需要注意返回的法线是视角空间下的法线方向。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>运动模糊
<ol>
<li>使用速度映射。通过深度纹理为每个像素计算其世界空间下的位置。并与前一帧的位置做差值，从而得到速度。好处是能够在一个屏幕后处理中完成整个效果，缺点就是性能消耗比较大。</li>
</ol>
</li>
<li>雾效
<ol>
<li>公式：<code>float3 afterFog = f * fogColor + (1 - f) * origColor</code>
<ol>
<li>雾效系数<code>f</code>的计算公式
<ol>
<li>线性：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>=</mo><mo>(</mo><msub><mi>d</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><mi mathvariant="normal">∣</mi><mi>z</mi><mi mathvariant="normal">∣</mi><mo>)</mo><mi mathvariant="normal">/</mi><mo>(</mo><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">f = (d_{max} - |z|)/({d_{max} - d_{min}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord">∣</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>指数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>d</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>z</mi><mi mathvariant="normal">∣</mi></mrow></msup></mrow><annotation encoding="application/x-tex">f = e^{-d*|z|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">d</span><span class="mbin mtight">∗</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mord mtight">∣</span></span></span></span></span></span></span></span></span></span></span></span></li>
<li>指数平方：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mo>(</mo><mi>d</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>z</mi><mi mathvariant="normal">∣</mi><msup><mo>)</mo><mn>2</mn></msup></mrow></msup></mrow><annotation encoding="application/x-tex">f = e^{-(d*|z|)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9869199999999998em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999998em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">d</span><span class="mbin mtight">∗</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mord mtight">∣</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="第14章-非真实感渲染">第14章 非真实感渲染</h1>
<h2 id="卡通风格渲染">卡通风格渲染</h2>
<h3 id="轮廓线">轮廓线</h3>
<ol>
<li>基于观察角度和法线：简单快速，但局限性很大，描边效果不好。</li>
<li>使用两个Pass，一个渲染背面，一个渲染正面。背面用纯色渲染稍微大一圈，组合到一起就是描边效果了。但这种方式仅仅适用于轮廓平滑的模型，不适用于立方体这类的模型。</li>
<li>基于图像处理的轮廓线渲染。使用算子进行边缘检测。适用范围广，效果较好。但一些深度法线变化小的轮廓可能无法检测出来。</li>
<li>基于轮廓边检测的轮廓线检测。原理是检测相邻的两个三角面的朝向是否不一致（是不是一个朝前一个朝后），如果不一致则两个三角面之间有一条轮廓线。但这种方式也有缺点，一个是实现复杂，另一个是动画在帧与帧之间不连贯。
<ol>
<li>公式：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>n</mi><mn>0</mn></msub><mo separator="true">⋅</mo><mi>v</mi><mo>&gt;</mo><mn>0</mn><mo>)</mo><mo>!</mo><mo>=</mo><mo>(</mo><msub><mi>n</mi><mn>1</mn></msub><mo separator="true">⋅</mo><mi>v</mi><mo>&gt;</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(n_0 · v &gt; 0) != (n_1 · v &gt; 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></li>
</ol>
</li>
</ol>
<h3 id="高光">高光</h3>
<p>卡通的高光相比于一般的高光来说，颜色过度更贱&quot;生硬&quot;。因此我们将普通的高光公式所求的的值，与一个阈值进行比较，小于该阈值直接为0，大于该阈值直接为1.</p>
<h2 id="素描风格渲染">素描风格渲染</h2>
<ol>
<li>使用了色调艺术映射的技术。</li>
<li>根据观察方向和法线的点积值，if判断，来确定使用那个贴图的素材。从而叠加渲染。</li>
</ol>
<h1 id="第15章-使用噪声">第15章 使用噪声</h1>
<ol>
<li>消融效果：在噪声图上采样，得到噪声值。然后将当前颜色值与噪声值进行比较，大于或者小于的直接将该片元discard。剩余的片元再次处理一下边缘颜色就可以了。</li>
<li>水波效果：基于时间，在法线噪声图上采样。用采样得到的法线值，计算颜色偏移等。</li>
<li>烟雾飘动的效果。</li>
</ol>
<h1 id="第16章-unity中的渲染优化技术">第16章 Unity中的渲染优化技术</h1>
<p>首要规则：过度优化和不优化一样严重。</p>
<p>此外有一篇关于Unity优化的导图文章特别好，写的很全。基本上按照那个导图一个流程走下来，性能应该没什么大问题。但因为那个导图是收费的，这里不好直接贴上来。放一个链接，有兴趣可以去查看。</p>
<p><a href="https://mm.edrawsoft.cn/store">在线思维导图(在搜索里搜Unity就能找到了)</a></p>
<h2 id="移动平台的特点">移动平台的特点</h2>
<ol>
<li>移动设备一般使用基于Tile的延迟渲染架构，即将图像装入一个个tile中。然后再由硬件选择将tile中的哪个图像渲染到屏幕上。</li>
<li>基于上面描述的渲染架构的特点，overDraw（就是一个像素被多次绘制）很有可能是性能瓶颈。</li>
</ol>
<h2 id="影响性能的因素">影响性能的因素</h2>
<ol>
<li>CPU
<ol>
<li>draw Call</li>
<li>逻辑</li>
<li>物理</li>
</ol>
</li>
<li>GPU
<ol>
<li>顶点
<ol>
<li>顶点过多</li>
<li>顶点计算过多</li>
</ol>
</li>
<li>片元
<ol>
<li>过多的片元</li>
<li>逐片元计算过多</li>
</ol>
</li>
</ol>
</li>
<li>带宽
<ol>
<li>尺寸过大的未压缩的纹理</li>
<li>分辨率过高的帧缓存</li>
</ol>
</li>
</ol>
<h2 id="unity中的分析工具">Unity中的分析工具</h2>
<ol>
<li>
<p>渲染统计信息。Game窗口的Stats<br>
<img src="https://singledigit9.github.io/post-images/1590816549696.jpeg" alt="" loading="lazy"><br>
<img src="https://singledigit9.github.io/post-images/1590816560024.jpeg" alt="" loading="lazy"></p>
</li>
<li>
<p>Profiler<br>
可以动态查看当前帧的消耗情况。但需要注意的是，编辑器下的调试有一定的参考价值，但和真机上还是有差别。</p>
</li>
<li>
<p>帧调试器<br>
可以看每一帧都渲染了什么东西，有什么东西是应该一起渲染的但是没有一起渲染（这个对FairyGUI尤其有用。优化时FairyGUI往往调整一下层级就会减少一些DrawCall）</p>
</li>
</ol>
<h2 id="动态批处理">动态批处理</h2>
<ol>
<li>顶点数小于900。如果Shader中使用了顶点位置，法线，纹理坐标这3个顶点属性，那么就要小于300</li>
<li>同一个缩放尺度下。（书上说Unity5之后已经对这个进行了优化，但我在Unity2018下用Cube进行试验，不同缩放尺度的Cube一样会增加DrawCall，想动态批处理的话，这个最好还是严格遵守）</li>
<li>需要动态批处理的物体应该指向光照纹理的同一个位置。（<strong>光照纹理这部分接触较少，需要深入学习</strong>）</li>
<li>多Pass的Shader会中断批处理操作。</li>
</ol>
<h2 id="静态批处理">静态批处理</h2>
<p>运行开始阶段，将需要静态批处理的网格合并到一个大网格中。<br>
静态批处理相比于动态批处理更加高效，但仍然有一些缺点。</p>
<ol>
<li>静态批处理的物体不能够移动</li>
<li>往往会占用更多的内存。因为一些物体如果共享了相同的网格，合并前每一个物体都会有一个该网格的复制。最终导致一个网格的多个复制会发给GPU，从而导致性能瓶颈。
<ol>
<li>例子：1000个相同模型的树，如果使用了静态批处理，则会吧这个模型的1000的复制合并到一个大网格里进行处理。也就是说，一个树的模型，我们多消耗了999个单位的内存空间。</li>
</ol>
</li>
</ol>
<h2 id="共享材质">共享材质</h2>
<p>关键字：shareMaterial</p>
<ol>
<li>使用Renderer.Material时，会创建一份原始材质球的复制，造成额外消耗。</li>
<li>使用Renderer.ShareMaterial时，会修改原始的材质球，从而使使用这个材质球的模型都收到影响。</li>
</ol>
<h2 id="减少顶点">减少顶点</h2>
<ol>
<li>模型制作，去除不必要的顶点和边</li>
<li>LOD</li>
<li>遮挡剔除技术（<strong>这个需要重点学习一下，之前没有用过。</strong>）</li>
</ol>
<h2 id="减少片元">减少片元</h2>
<ol>
<li>减少overDraw
<ol>
<li>最最主要的，尽可能不要用半透明的渲染队列。半透明物体会破坏渲染队列。</li>
<li>对于UI，如果无法避免半透明，可以将UI的相机和其他的场景相机分开，不要一起渲染。</li>
<li>透明度测试也会影响游戏性能。discard和clip操作可能会导致一些硬件的优化策略失败。</li>
</ol>
</li>
<li>减少实时光照和阴影
<ol>
<li>灯光贴图</li>
<li>移动平台上，物体的逐像素光照光源数目应该小于1（不包括平行光）。如果为了效果需要多个光源，请使用逐顶点光照。</li>
<li>将光照计算存储到纹理中。根据光源方向，视角方向，法线方向等直接从纹理采样得到信息。但这种方法需要编写对应的美术编辑器，</li>
</ol>
</li>
</ol>
<h2 id="较少带宽">较少带宽</h2>
<ol>
<li>减少纹理大小。纹理大小应该是2的整数次幂。纹理压缩格式在不影响效果的情况下，应该压缩到最小。</li>
<li>有些设备空有高分辨率的屏幕而没有配套的其他硬件，从而导致游戏在那个设备上运行时效果不好。可以使用Screen.SetResolution来设置分辨率。（<strong>这块需要进一步查阅资料学习</strong>）</li>
</ol>
<h2 id="减少计算复杂度">减少计算复杂度</h2>
<ol>
<li>Shader中的LOD
<ol>
<li>只有Shader中的LOD小于指定值时，这个Shader才会被使用。</li>
<li>内置的Diffuse的LOD是200，BumpedSpecular是400。</li>
</ol>
</li>
<li>Shader代码
<ol>
<li>计算数目排序：物体数量 &lt; 顶点数量 &lt; 片元数量</li>
<li>尽可能把计算上移，减少计算。</li>
<li>尽可能使用低精度浮点数进行计算</li>
<li>避免不同精度数来回切换</li>
<li>避免频繁的color.rgrg操作</li>
<li>尽可能不要用屏幕后处理</li>
<li>如果需要使用屏幕后处理，尽可能把多个特效封到一个Shader里</li>
<li>尽可能不要用分支和循环，sin, tan, pow，等费时操作，以及discard操作。</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AssetBundle官方文档学习笔记]]></title>
        <id>https://singledigit9.github.io/post/assetbundle-guan-fang-wen-dang-xue-xi-bi-ji/</id>
        <link href="https://singledigit9.github.io/post/assetbundle-guan-fang-wen-dang-xue-xi-bi-ji/">
        </link>
        <updated>2020-05-13T14:14:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="文档版本地址">文档版本&amp;地址</h1>
<p>2019.3 <a href="https://docs.unity3d.com/Manual/AssetBundlesIntro.html">https://docs.unity3d.com/Manual/AssetBundlesIntro.html</a></p>
<h1 id="官方工具">官方工具</h1>
<p><a href="https://docs.unity3d.com/Packages/com.unity.addressables@1.8/manual/index.html">Unity Addressable Asset system</a><br>
<a href="https://github.com/Unity-Technologies/AssetBundles-Browser">Unity Asset Bundle Browser tool</a><br>
<a href="https://docs.unity3d.com/Manual/AssetBundles-Browser.html">Unity Asset Bundle Browser tool文档</a></p>
<h1 id="基础介绍">基础介绍</h1>
<h2 id="assetbundle的特性">AssetBundle的特性</h2>
<ul>
<li>AssetBundle能够互相依赖。例如，一个AssetBundle中的材质球能够引用另一个AssetBundle上的贴图。</li>
<li>AssetBundle能够使用Unity内置的算法进行压缩，以提高传输效率。</li>
</ul>
<h2 id="assetbundle能够做什么">AssetBundle能够做什么</h2>
<ul>
<li>DLC的更新</li>
<li>减少初始安装包大小</li>
<li>减小运行时内存压力</li>
<li>针对用户的终端（手机）加载优化资源</li>
</ul>
<h2 id="assetbundle文件和assetbundle对象">AssetBundle文件和AssetBundle对象</h2>
<ul>
<li>AssetBundle文件中包含的是打入其中的各种资源。</li>
<li>AssetBundle对象中有一个Key值为路径，Value值为对应资源的字典。</li>
</ul>
<h1 id="工作流程">工作流程</h1>
<h2 id="资源的设置">资源的设置</h2>
<ol>
<li>选中要打包的资源，在检视面板的最下面可以看到AssetBundle配置选项。</li>
<li>第一个配置：要将这个资源打进哪一个AssetBundle<strong>待测试</strong></li>
<li>第二个配置：这个资源的变体<strong>待测试</strong></li>
</ol>
<h2 id="资源的打包">资源的打包</h2>
<p>官网提供了示例代码<strong>待测试</strong></p>
<pre><code>using UnityEditor;
using System.IO;

public class CreateAssetBundles
{
    [MenuItem(&quot;Assets/Build AssetBundles&quot;)]
    static void BuildAllAssetBundles()
    {
        string assetBundleDirectory = &quot;Assets/AssetBundles&quot;;
        if(!Directory.Exists(assetBundleDirectory))
        {
            Directory.CreateDirectory(assetBundleDirectory);
        }
        BuildPipeline.BuildAssetBundles(assetBundleDirectory, 
                                        BuildAssetBundleOptions.None, 
                                        BuildTarget.StandaloneWindows);
    }
}
</code></pre>
<h2 id="加载assetbundle和assetbundle里面的资源">加载AssetBundle和AssetBundle里面的资源</h2>
<h3 id="加载本地文件">加载本地文件</h3>
<p>官网示例代码<strong>待测试</strong></p>
<pre><code>public class LoadFromFileExample : MonoBehaviour {
    function Start() {
        var myLoadedAssetBundle 
            = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, &quot;myassetBundle&quot;));
        if (myLoadedAssetBundle == null) {
            Debug.Log(&quot;Failed to load AssetBundle!&quot;);
            return;
        }
        var prefab = myLoadedAssetBundle.LoadAsset&lt;GameObject&gt;(&quot;MyObject&quot;);
        Instantiate(prefab);
    }
}
</code></pre>
<h3 id="加载网络文件">加载网络文件</h3>
<pre><code>IEnumerator InstantiateObject()
{
    string url = &quot;file:///&quot; + Application.dataPath + &quot;/AssetBundles/&quot; + assetBundleName;        
    UnityEngine.Networking.UnityWebRequest request 
        = UnityEngine.Networking.UnityWebRequest.GetAssetBundle(url, 0);
    yield return request.Send();
    AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);
    GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;);
    GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;(&quot;Sprite&quot;);
    Instantiate(cube);
    Instantiate(sprite);
}
</code></pre>
<h1 id="打包策略">打包策略</h1>
<ul>
<li>开发人员应该明确知道在什么时候什么位置使用什么资源。明确了这个问题后才能够决定使用什么打包策略。</li>
</ul>
<h2 id="依据实体打包">依据实体打包</h2>
<ul>
<li>举例：
<ul>
<li>将一个UIPrefab和它所用到的贴图打包在一起</li>
<li>将一个模型和这个模型的材质球，贴图，动画文件打包在一起</li>
<li>将一个场景和这个场景所用到的资源打包在一起</li>
</ul>
</li>
<li>特点
<ul>
<li>每个实体的AssetBundle是分开的，更新单独的实体时不用更新其他没有改变的资源</li>
</ul>
</li>
</ul>
<h2 id="依据资源类型打包">依据资源类型打包</h2>
<ul>
<li>特点
<ul>
<li>不同平台下压缩格式相同的资源AssetBundle可以在不同平台下重用</li>
</ul>
</li>
</ul>
<h2 id="选择正确的打包策略">选择正确的打包策略</h2>
<ul>
<li>AssetBundle是有依赖关系的。如果你的AssetBundle打包策略不好，可能会出现想加载一个GameObject而需要加载多个AssetBundle的情况。</li>
<li>上面两种策略当然也可以混合使用。这需要根据具体的项目需求来进行选择。</li>
</ul>
<h3 id="关键点">关键点</h3>
<ul>
<li>将经常变化的资源和很少变化的资源分开打包。</li>
<li>理清资源依赖关系，避免复杂的相互依赖。比如将通用的依赖资源移到Common中。</li>
<li>不可能同时加载使用的资源不要打进一个AssetBundle里</li>
<li>如果一个AssetBundle中只有一部分资源被频繁的加载，那么需要把这个AssetBundle进行拆分</li>
<li>将同时频繁加载的小（资源数少于5-10）的AssetBundle合并到一起。</li>
<li>不同版本的同一物体，可以考虑使用变体 <strong>变体具体是什么待测试</strong></li>
</ul>
<h1 id="打包assetbundle">打包AssetBundle</h1>
<h2 id="buildassetbundleoptions">BuildAssetBundleOptions</h2>
<ul>
<li>关于打AssetBundle的各种设置  <strong>待测试</strong></li>
</ul>
<table>
<thead>
<tr>
<th>API</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>没有特殊设置。使用LZMA进行压缩</td>
</tr>
<tr>
<td>UncompressedAssetBundle</td>
<td>不对AssetBundle进行压缩</td>
</tr>
<tr>
<td>DisableWriteTypeTree</td>
<td>AssetBundle中不包含类型信息</td>
</tr>
<tr>
<td>DeterministicAssetBundle</td>
<td>确保相同的资源打进AssetBundle里面后，哈希值不会变化</td>
</tr>
<tr>
<td>ForceRebuildAssetBundle</td>
<td>强制重新打AssetBundle</td>
</tr>
<tr>
<td>IgnoreTypeTreeChanges</td>
<td>增量打包时忽略类型树变化</td>
</tr>
<tr>
<td>AppendHashToAssetBundleName</td>
<td>将Hash值添加到AssetBundle名字之后，能够从名字直接看出AssetBundle是否有变化</td>
</tr>
<tr>
<td>ChunkBasedCompression</td>
<td>使用LZ4格式压缩</td>
</tr>
<tr>
<td>StrictMode</td>
<td>打包过程中报错则中断打包</td>
</tr>
<tr>
<td>DryRunBuild</td>
<td>Do a dry run build.</td>
</tr>
<tr>
<td>DisableLoadAssetByFileName</td>
<td>不允许使用文件名字加载资源</td>
</tr>
<tr>
<td>DisableLoadAssetByFileNameWithExtension</td>
<td>不允许使用带后缀的文件名字加载资源</td>
</tr>
<tr>
<td>AssetBundleStripUnityVersion</td>
<td>构建时删除Unity版本号</td>
</tr>
</tbody>
</table>
<h2 id="关于压缩格式">关于压缩格式</h2>
<ul>
<li>默认情况下，使用LZMA格式创建，使用LZ4格式缓存</li>
</ul>
<h3 id="压缩格式类型">压缩格式类型</h3>
<ul>
<li>LZMA：
<ul>
<li>打出的AssetBundle最小，但加载时间也会更长（加载资源之前需要先将资源所在的AssetBundle整个进行解压）。</li>
<li>资源解压后，会使用LZ4格式重新压缩。</li>
<li>推荐在初始资源下载时使用这个格式。</li>
<li>通过<code>UnityWebRequestAssetBundle</code>加载的LZMA格式的AssetBundle会自动解压并重新压缩为LZ4，缓存到本地。如果是使用其他方式下载的Assetbundle,则可以使用<code>AssetBundle.RecompressAssetBundleAsync</code>对其进行重新压缩</li>
</ul>
</li>
<li>LZ4：
<ul>
<li>加载资源前不必对整个AssetBundle进行解压</li>
<li>允许以块的形式加载资源。解压单个块，即使当前AssetBund中其他的块没有解压，也能使用当前块中的资源</li>
<li>这种压缩模式下<code>AssetBundle.LoadFromFile</code>只在内存里加载Bundle的资源目录，而不是Bundle本身</li>
</ul>
</li>
<li>完全不压缩：
<ul>
<li>文件大，加载快</li>
</ul>
</li>
</ul>
<h2 id="打包生成的文件">打包生成的文件</h2>
<ul>
<li>
<p>AssetBundle文件</p>
<ul>
<li>场景Bundle和其他一般资源Bundle里面的结构略有不同。场景的Bundle有一些特殊优化。<br>
<img src="https://singledigit9.github.io/post-images/1589379363606.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>
<p>Manifest文件</p>
<ul>
<li>包含了当前AssetBundle的资源信息以及资源的依赖信息</li>
</ul>
</li>
</ul>
<h1 id="assetbundle依赖">AssetBundle依赖</h1>
<ul>
<li>一个Bundle中的资源引用另一个Bundle中的资源会产生依赖；一个Bundle中的资源引用一个不在Bundle中的资源不会产生依赖。</li>
<li>如果Bundle中资源A引用不在Bundle中的资源B，则资源B会被复制并打进A的Bundle中。</li>
<li>如果多个Bundle中的资源引用不在Bundle中的资源B，则资源B会被复制并打进每一个Bundle中。</li>
<li>如果要加载的Bundle A中的资源依赖Bundle B，那么加载这个资源前要先将Bundle B加载好。</li>
</ul>
<h2 id="跨assetbundle的重复信息">跨AssetBundle的重复信息</h2>
<ul>
<li>如果一个Bundle中有一个预制，都引用了不在Bundle中的材质球和贴图
<ul>
<li>影响最终打出来的Bundle大小增加</li>
<li>运行时内存占用增加</li>
<li>影响Unity自动批处理。Unity把不同Bundle中的材质球都看作是唯一的。</li>
</ul>
</li>
</ul>
<h2 id="编辑器下依赖关系的查询">编辑器下依赖关系的查询</h2>
<ul>
<li><code>AssetDatabase</code>：查询依赖关系</li>
<li><code>AssetImporter</code>：查询资源分配到了哪个AssetBundle</li>
</ul>
<h2 id="几种依赖关系的处理方法">几种依赖关系的处理方法</h2>
<ul>
<li>共同的依赖资源集中到一个Bundle里面（不适用于复杂交叉依赖的情况）</li>
<li>确保同一时间，不会有任何一个Bundle有多重被依赖。（适用于基于Level的游戏，但这样做仍然会增加AssetBundle的文件大小）</li>
<li>确保所有依赖的资源都在自己的AssetBundle里面。但这样做机制比较复杂。</li>
</ul>
<h1 id="assetbundle的使用">AssetBundle的使用</h1>
<h2 id="加载assetbundle">加载AssetBundle</h2>
<ul>
<li><code>AssetBundle.LoadFromMemoryAsync</code>
<ul>
<li>从内存异步加载AssetBundle</li>
<li>参数为Bundle文件的字节流</li>
<li>使用示例：</li>
</ul>
</li>
</ul>
<pre><code>using UnityEngine;
using System.Collections;
using System.IO;

public class Example : MonoBehaviour
{
    IEnumerator LoadFromMemoryAsync(string path)
    {
        AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path));
        yield return createRequest;
        AssetBundle bundle = createRequest.assetBundle;
        var prefab = bundle.LoadAsset&lt;GameObject&gt;(&quot;MyObject&quot;);
        Instantiate(prefab);
    }
}
</code></pre>
<ul>
<li><code>AssetBundle.LoadFromFile</code>
<ul>
<li>未压缩和LZ4格式压缩的AssetBundle，会直接从硬盘中加载。加载LZMA格式的AssetBundle时，会先解压，然后再加载。</li>
<li>加载本地的未压缩资源效率很高。</li>
<li>Unity5.3以及以前版本，Android平台使用这个API加载StreamingAssets文件夹中的AssetBundle会失败。因为StreamingAssets文件夹中的内容会在一个压缩的.jar文件中。</li>
<li>Unity5.4以及更新的版本能够正常的使用这个API.</li>
<li>使用示例：</li>
</ul>
</li>
</ul>
<pre><code>public class LoadFromFileExample : MonoBehaviour {
    function Start() {
        var myLoadedAssetBundle 
            = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, &quot;myassetBundle&quot;));
        
        if (myLoadedAssetBundle == null) {
            Debug.Log(&quot;Failed to load AssetBundle!&quot;);
            return;
        }
        var prefab = myLoadedAssetBundle.LoadAsset.&lt;GameObject&gt;(&quot;MyObject&quot;);
        Instantiate(prefab);
    }
}
</code></pre>
<ul>
<li><code>UnityWebRequest</code>
<ul>
<li>相当于原来的<code>WWW</code>类的升级版。</li>
<li>能够方便的处理下载以及HTTP的Get/POST请求。</li>
<li>使用示例：</li>
</ul>
</li>
</ul>
<pre><code>IEnumerator InstantiateObject()
{
    string uri = &quot;file:///&quot; + Application.dataPath + &quot;/AssetBundles/&quot; + assetBundleName; 
    UnityEngine.Networking.UnityWebRequest request 
        = UnityEngine.Networking.UnityWebRequest.GetAssetBundle(uri, 0);
    yield return request.Send();
    AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);
    GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;);
    GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;(&quot;Sprite&quot;);
    Instantiate(cube);
    Instantiate(sprite);
}
</code></pre>
<ul>
<li><code>WWW.LoadFromCacheOrDownload</code>[已淘汰，直接跳过]</li>
</ul>
<h2 id="加载assetbundle中的资源">加载AssetBundle中的资源</h2>
<ul>
<li><code>T objectFromBundle = bundleObject.LoadAsset&lt;T&gt;(assetName);</code></li>
<li><code>Unity.Object[] objectArray = loadedAssetBundle.LoadAllAssets();</code></li>
<li></li>
</ul>
<pre><code>AssetBundleRequest request = loadedAssetBundleObject.LoadAssetAsync&lt;GameObject&gt;(assetName);
yield return request;
var loadedAsset = request.asset;
</code></pre>
<ul>
<li></li>
</ul>
<pre><code>AssetBundleRequest request = loadedAssetBundle.LoadAllAssetsAsync();
yield return request;
var loadedAssets = request.allAssets;
</code></pre>
<h2 id="加载manifest文件">加载Manifest文件</h2>
<ul>
<li>加载Manifest文件是为了解决依赖问题</li>
<li>加载Manifest文件的示例代码</li>
</ul>
<pre><code>AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);
AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;);
</code></pre>
<ul>
<li>查询并加载依赖的示例代码</li>
</ul>
<pre><code>AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);
AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;);
string[] dependencies = manifest.GetAllDependencies(&quot;assetBundle&quot;); //Pass the name of the bundle you want the dependencies for.
foreach(string dependency in dependencies)
{
    AssetBundle.LoadFromFile(Path.Combine(assetBundlePath, dependency));
}
</code></pre>
<h1 id="管理加载的assetbundle">管理加载的AssetBundle</h1>
<ul>
<li>不正确的卸载AssetBundle可能导致复制内存中的object或者其他问题，比如贴图丢失。</li>
</ul>
<h2 id="assetbundleunloadbool"><code>AssetBundle.Unload(bool)</code></h2>
<ul>
<li>卸载AssetBundle的头部信息</li>
</ul>
<h3 id="参数详细说明">参数详细说明</h3>
<ul>
<li>参数为true时 也卸载AssetBundle所有的实例化对象，这个实例化对象不包含对象的复制（复制的资源不是AssetBundle里面的资源）。</li>
<li>多数情况下，会使用true来保证内存中没有重复的对象</li>
<li>如果参数必须为false的话，内存中无法访问的资源只能通过以下方式卸载
<ul>
<li>手动调用<code>Resources.UnloadUnusedAssets</code></li>
<li>非添加方式加载场景，会自动调用<code>Resources.UnloadUnusedAssets</code></li>
</ul>
</li>
</ul>
<h4 id="详细例子">详细例子</h4>
<ul>
<li>从AssetBundle中加载的一个GameObject资源，true卸载时，会把这个GameObject资源卸载掉，而不会把Instantiate的GameObject也卸载掉。</li>
<li>现在从AssetBundle中加载一个材质球在活动场景中使用
<ul>
<li>使用Unload(true)卸载时，材质球在场景中的所有实例一样会被卸载和销毁。<strong>这里有个疑问待测试：Instantiate的材质球会不会也被销毁</strong></li>
<li>使用Unload(false)卸载时，会打断当前材质球和AssetBundle的链接。如果AssetBundle重新加载，它并不会链接到已经存在的材质球。此时加载该材质球时，会复制一个新的。</li>
</ul>
</li>
</ul>
<p><img src="https://singledigit9.github.io/post-images/1589379410371.png" alt="" loading="lazy"><br>
<img src="https://singledigit9.github.io/post-images/1589379417761.png" alt="" loading="lazy"><br>
<img src="https://singledigit9.github.io/post-images/1589379424865.png" alt="" loading="lazy"></p>
<h2 id="保证资源不重复的方法">保证资源不重复的方法</h2>
<ul>
<li>在恰当的时机卸载暂时加载的AssetBundle，比如Loading时</li>
<li>记录资源加载的引用计数，避免重复加载资源和异常卸载资源</li>
</ul>
<h1 id="assetbundle缓存">AssetBundle缓存</h1>
<ul>
<li>Unity维护两个缓存，分别是内存缓存和硬盘缓存。</li>
<li>将AssetBundle中加载到内存中，会消耗大量的内存空间。除非有特别频繁快速访问AssetBundle中内容的需求，否则请使用磁盘缓存。</li>
<li>如果你向<code>UnityWebRequest</code>提供了一个版本参数（版本号挥着Hash），Unity会将AssetBundle数据存储到本地硬盘。如果不提供参数，Unity将会使用内存缓存。</li>
<li><code>Caching.compressionEnabled</code>设置为true时，存储到本地的AssetBundle文件会以LZ4的格式进行压缩；设置为false时，则存储到本地的文件不会压缩。</li>
<li>使用LZMA格式初始加载会耗费比较长的时间。因为它需要先解压，然后以指定格式存储到硬盘缓存。之后加载会直接使用缓存来加载。</li>
<li>推荐使用<code>UnityWebRequest</code>，因为<code>AssetBundle.LoadFromFile</code>和<code>AssetBundle.LoadFromFileAsync</code>加载LZMA后会使用内存中的缓存。如果不能使用<code>UnityWebRequest</code>，可以使用<code>AssetBundle.RecompressAssetBundleAsync</code>手动将AssetBundle数据写到硬盘缓存上。</li>
<li>内部测试表明，使用磁盘缓存和内存缓存存在着一个数量级的差异。需要根据项目的需求自己权衡。</li>
</ul>
<h2 id="缓存类型">缓存类型</h2>
<ol>
<li>内存缓存：AssetBundle为不压缩格式</li>
<li>硬盘缓存：在可写空间以指定格式压缩保存AssetBundle文件</li>
</ol>
<h1 id="assetbundle补丁">AssetBundle补丁</h1>
<ul>
<li>下载一个新的AssetBundle来替换现有的AssetBundle</li>
<li>使用<code>UnityWebRequest</code>API时，会根据传入的版本参数自动触发下载新的AssetBundle</li>
<li>Unity使用固定方式生成AssetBundle文件，也就是说，资源不变，生成的AssetBundle也是不变的。正因为这样，可以自定义下载器来区分补丁差异。</li>
<li>Unity内部并没有实现差分补丁的功能，如果有差分补丁的需求的话，需要手动实现。（差分补丁：新AssetBundle和旧AssetBundle进行比较生成补丁。客户端下载补丁并经过处理生成新AssetBundle）</li>
</ul>
<h2 id="如何确定要替换的assetbundle">如何确定要替换的AssetBundle</h2>
<ul>
<li>从服务器获取要下载的资源列表和版本信息。和本地的资源列表版本信息做对比。如果本地资源缺失或者版本号不对，则需要下载替换这个AssetBundle。</li>
<li>也可以自定义系统来检测AssetBundle变化，比如MD5，JSON等。</li>
</ul>
<h1 id="常见问题">常见问题</h1>
<h2 id="自动生成的图集">自动生成的图集</h2>
<ul>
<li>如果一个图集的所有sprite都打进同一个Bundle，则自动生成的图集将会打进这个Bundle。</li>
<li>如果sprite被打进多个Bundle，那么图集会复制多分分别打进对应的Bundle。</li>
<li>如果sprite没有被打进Bundle，那么图集也不会被打进Bundle</li>
<li>Unity5.2.2p3以及以前的版本对图集打Bundle的支持有问题。</li>
</ul>
<h2 id="android-texture">Android Texture</h2>
<ul>
<li>Android设备碎片化问题严重，需要将贴图压缩成对应的格式。</li>
<li>ETC1没有透明通道，但基本上所有设备都支持</li>
<li>ETC2，旧设备可能不支持</li>
<li>可以使用变体，将不同变体的贴图分别打在一个AssetBundle里面，根据情况进行加载。（需要贴图设置正确）</li>
<li><code>SystemInfo.SupportedTextureFormat</code>可以使用这个API来检测设备支持什么格式的贴图</li>
</ul>
]]></content>
    </entry>
</feed>