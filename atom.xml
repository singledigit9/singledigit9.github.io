<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://singledigit9.github.io</id>
    <title>资料库</title>
    <updated>2020-06-10T18:52:44.594Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://singledigit9.github.io"/>
    <link rel="self" href="https://singledigit9.github.io/atom.xml"/>
    <subtitle>One By One</subtitle>
    <logo>https://singledigit9.github.io/images/avatar.png</logo>
    <icon>https://singledigit9.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 资料库</rights>
    <entry>
        <title type="html"><![CDATA[面试准备]]></title>
        <id>https://singledigit9.github.io/post/mian-shi-zhun-bei/</id>
        <link href="https://singledigit9.github.io/post/mian-shi-zhun-bei/">
        </link>
        <updated>2020-06-09T15:08:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1>
<p>那个猎头哥们说网易的另外的做VR游戏的部门要联系我。聊一聊VR游戏什么的。<br>
想着别人主动邀请聊一聊还是可以的。<br>
但答应了之后，觉得那兄弟可能是在套路我。不过也没啥关系啦，那兄弟很负责，自己之前一面都没过实在是说不过去。<br>
所以要好好准备准备。</p>
<hr>
<h1 id="招聘官网上搜索到的职位信息">招聘官网上搜索到的职位信息</h1>
<h2 id="信息2">信息2</h2>
<p>职位描述</p>
<p>职责描述：<br>
1.负责客户端相关逻辑的脚本开发；<br>
2.负责游戏客户端调优；<br>
3.负责游戏客户端模块设计和开发。<br>
职位要求</p>
<p>任职要求：<br>
1.2年以上游戏客户端开发经验<br>
2 至少熟悉Python/lua一种脚本语言的优先考虑</p>
<ol>
<li>至少熟悉Unity3D/Unreal4一款引擎的优先考虑</li>
<li>具有良好的编程能力、代码风格和编程习惯、熟练掌握常用数据结构及算法</li>
<li>热爱游戏，能适应手游开发节奏者优先。</li>
</ol>
<h1 id="信息整理">信息整理</h1>
<ol>
<li>Lua</li>
<li>Unity<br>
技能完全命中，准备好概率比较大。</li>
</ol>
<h1 id="常见问题">常见问题</h1>
<h2 id="自我介绍-2403min">自我介绍 （2:40）[3min]</h2>
<p>面试官你好，我叫王洪庆，毕业于西安交通大学工程力学系。<br>
我是从15年末开始，到现在一直在做Unity客户端。做过手游和VR相关的东西。<br>
刚工作时候做的是手游，当时负责的就是一些UI相关功能的开发，比如背包，卡牌培养，商店之类的。<br>
后来加入了一个创业团队做VR的东西。刚开始做的东西也是比较简单。比如说在VR射击游戏里面负责道具功能的实现，就是加血无限子弹之类的。还有简单的飞机模拟VR游戏，这个主要是做的游戏的整理流程，和座椅设备的串口接入。<br>
再之后就是做VR教育相关的东西。当时的主要产品大致描述就是由教师端通过服务器控制学生端VR设备的显示内容。我是主要负责课程部分SDK和部分课程内容的制作。这一部分由于当时人比较少，是自己独立完成的。产品完成后，公司逐渐偏向销售，氛围比较安逸，但觉得自己还没到能养老的时候。<br>
于是到灵游坊组做客户端开发。开发的游戏是2D回合制游戏。我负责UI功能，战斗逻辑和表现部分，编辑器工具等。</p>
<h2 id="觉得自己做的最好的是哪个项目详细描述一下做了什么-1302min">觉得自己做的最好的是哪个项目，详细描述一下做了什么。（1:30）[2min]</h2>
<p>我最满意的还是《群星守卫》这款手游吧。代码方面，在之前积累的基础上，有所进步。表现效果方面，项目的流程是先由美术设计做效果视频，然后客户端对效果视频进行逆向还原。最终还原的效果基本上能达到效果视频的80%以上。此外，因为有美术效果设计的过于复杂，UI动画还原的效果不好，所以广泛使用了CriWare视频插件。视频插件的封装工作是我负责的，在原来插件的基础上，实现了Intro-Loop模式播放视频，以及视频的切换。</p>
<h2 id="项目中遇到了那些难点怎么解决的-4305min">项目中遇到了那些难点，怎么解决的。（4:30）[5min]</h2>
<p>项目中遇到的难点就是封装视频插件那块了。插件本身是不开源的，里面由不少代码做了混淆，看不到内部实现机制，只能看到外层的播放器。需求要实现IntroLoop效果，我先是看的官方的Demo，发现官方Demo虽然有切换视频的Demo，但因为插件播放视频需要一个Prepare的过程，所以Demo中两个视频之间切换需要卡几帧，很影响展现效果。然后就想着把第二个视频的Prepare的过程移动到第一个视频播放过程中去。于是采用的第一个方案就是创建不同的视频播放材质球，用直接切换材质球的方式实现视频的切换。但这种方案在材质球切换的时候，有几率会闪材质丢失的哪种粉色粉。为了解决这个问题，进一步研究插件的API，文档，发现有Append的方法可以进行视频拼接。按照这个思路改进，使用一个视频播放器和材质球，发现这种方式的限制很大，首先是视频格式的问题，视频格式要求Intro和Loop一致，且只能用Criware工具压缩的标准格式，h264格式的视频在append的时候有几率失败，而标准格式的体积比较大，而项目中使用视频的量很多，考虑包体积的问题，放弃了这个方案。最后是使用一个材质球，切换多个视频播放器开实现的。在视频播放前，先将Intro和Loop的播放器Prepare，之后Intro完毕后启动Loop进行播放，实现了这个需求。</p>
<h2 id="你觉得你的优点是什么030">你觉得你的优点是什么（0:30）</h2>
<p>觉得自己上手新东西的速度还算块吧，除了这个脾气好可能也算一个。</p>
<h2 id="你觉得自己的缺点是什么030">你觉得自己的缺点是什么（0:30）</h2>
<p>平时一般比较安静，不怎么善于活跃气氛。</p>
<h2 id="怎么看待加班200">怎么看待加班（2:00）</h2>
<p>身为程序。加班是无法避免的，毕竟工作量在那，肯定是每星期按天分好工作量，当天工作量完不成，加班算是必须的了，当天任务完不成，拖进度是害人害己的事，肯定不能这么干。如果是任务量不是很大，然后自己还天天要加班，我一般会看看是不是自己工作方法工作状态什么的出了问题，及时调整，向同事请教些经验。</p>
<p>总体来说就是，自己现在单身，也没什么顾虑，加班完成工作自然义不容辞。此外，能够不断提高自己的效率，让自己不用加班也能完成指定工作，那当然是最好的。</p>
<h2 id="薪资要求100">薪资要求（1:00）</h2>
<p>在我现在的薪资上有所提升就行了。<br>
【必须说数字的话，要20。尽量让HR先说】</p>
<h2 id="职业规划100">职业规划（1:00）</h2>
<p>自己的想法是进一步提升自己的技术实力。除了完善自己本身的知识体系之外，向进一步在计算机图形学方面进行深入研究。至于职位这方面，我是觉得程序作为一个技术人员，技术越来越厉害就是最好的职业规划了。</p>
<h2 id="还有什么问题要问500~1000">还有什么问题要问（5:00～10:00）</h2>
<ol>
<li>能大致介绍一下现在项目的情况么？</li>
<li>如果我能够入职，需要我在入职前做什么准备么？</li>
<li>如果我能入职，需要我负责那一方面的工作？</li>
</ol>
<h2 id="求职动机">求职动机</h2>
<ol>
<li>首先来说，网易是大厂，各个方面是要超过一般的小厂的。各个方面来说，对自己的职业发展和个人成长都很有帮助。</li>
</ol>
<h2 id="基础知识">基础知识</h2>
<h3 id="c的gc问题">C#的GC问题</h3>
<ol>
<li>GC步骤
<ol>
<li>搜索被引用的托管对象</li>
<li>确定没有被引用的对象</li>
<li>释放没有被引用的对象同时回收内存占用</li>
</ol>
</li>
<li>GC是什么：垃圾回收。C#中自动回收不使用的对象。</li>
<li>.Net GC的缺陷
<ol>
<li>不能释放所有的资源，只能释放托管的资源</li>
<li>GC并不是实时的，可能会造成性能瓶颈</li>
</ol>
</li>
<li>什么事托管资源什么事非托管资源
<ol>
<li>托管资源就是.Net能够直接回收的，主要是指分配在堆上的资源。托管资源的回收不需要人工干预，自动回收。</li>
<li>非托管资源就是.Net不知道怎么回收的。Unity里面的例子就比如说贴图，音效等等。需要我们在Unity层面手动管理加载释放的资源。</li>
</ol>
</li>
<li>可以调用<code>GC.Collect();</code>强制回收</li>
<li>GC是怎么影响性能的
<ol>
<li>GC是一个后台线程</li>
<li>当GC进行时，会将当前所有的线程挂起，执行完释放操作后才接着执行正常的程序逻辑。所以频繁GC会导致卡顿。</li>
</ol>
</li>
<li>GC的策略
<ol>
<li>标记压缩算法
<ol>
<li>从静态变量，静态对象，局部对象，函数调用参数等出发，查找标记所有当前引用的对象。</li>
<li>总对象已知，存在引用的对象已知，就能知道没有被引用的对象</li>
<li>将没有引用的对象进行回收</li>
<li>将不连续的内存压缩成连续的</li>
<li>修复指针（引用关系）</li>
</ol>
</li>
<li>分代算法
<ol>
<li>分代算法是一个和概率有关的算法
<ol>
<li>前提：
<ol>
<li>大量创建的对象生命周期比较短，老的对象生命周期比较长</li>
<li>对部分内存回收，比对所有内存回收要快</li>
<li>新创建的对象关联程度较强。</li>
</ol>
</li>
<li>托管堆分配对象内存是连续的。.Net将托管堆分成3个代龄区域，Gen0，Gen1，Gen2</li>
<li>0代达到阈值，触发0代GC，幸存的进入1代。成本低</li>
<li>1代达到阈值，触发1代GC，1代GC同时回收0代和1代。幸存的进入2代。成本低</li>
<li>2代GC将和0代1代2代一起回收。成本一般较高。</li>
<li>0～2回收频率：100:10:1</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="网络">网络</h3>
<p>TCP和UDP的区别</p>
<h3 id="值类型引用类型">值类型，引用类型</h3>
<h3 id="结构体和类">结构体和类</h3>
<h3 id="渲染流程">渲染流程</h3>
<p>1.如何优化内存,CPU,GPU开销</p>
<p>2.MonoBehavior生命周期函数，这些函数是是否属于MonoBehavior的父类虚函数？</p>
<p>3.Crash异常崩溃后如何快速定位</p>
<p>4.热更新技术ToLua,XLua,ILRuntime的区别与技术选型</p>
<p>5.协同程序实现原理</p>
<p>6.各类烘焙（光照贴图烘焙，遮挡剔除烘焙，NavMesh烘焙）的原理与用法</p>
<p>7.堆栈在内存中的存放顺序，说明堆栈的区别</p>
<p>8.Xml,Json,Protobuffer等序列化的区别。如何选型</p>
<p>9.解释ECS的概念和思想，如何应用，又用在何处</p>
<p>10.帧同步与状态同步的区别与优缺点，什么类型的游戏应该选项什么样的同步方式？</p>
<h2 id="算法题">算法题</h2>
<p>这个，收到问题，先问边界条件。<br>
之后想到什么直接说。<br>
再进一步启发思考。<br>
别tmd想太多，想太多不说话，别人就以为你啥啥不会。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SimpleFramework的相关文档]]></title>
        <id>https://singledigit9.github.io/post/simpleframework-de-xiang-guan-wen-dang/</id>
        <link href="https://singledigit9.github.io/post/simpleframework-de-xiang-guan-wen-dang/">
        </link>
        <updated>2020-06-06T09:37:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>这个框架算是为了总结自己所掌握的东西的一个总结。目标是基于Unity和FairyGUI，完成一个轻量的方便使用的游戏框架。<br>
目前完成了一部分，还有不少内容需要填充和测试，空闲时间一点一点来做吧。</p>
<h2 id="碎碎念">碎碎念</h2>
<p>其实之前自己也写过一些半残的东西，不过很多都不成体系，模块不全。此外也是深感自己在技术学习上有种<strong>N乘50%<strong>的感觉，想总体回顾一下，把欠缺的东西补到</strong>100%</strong>。<br>
这个文档主要是记录自己已经完成了什么，完成的部分该怎么使用。以及还没有完成什么，已经完成的部分有哪些优化空间；以及一些临时想到的可以做的编辑器工具等等。<br>
希望今年年底能够完成所有主体功能，且都测试过，也就是传说中的1.0版本。</p>
<h1 id="已完成测试">已完成测试</h1>
<h2 id="对象池">对象池</h2>
<h2 id="状态机">状态机</h2>
<h2 id="事件系统">事件系统</h2>
<h2 id="调试工具部分">调试工具[部分]</h2>
<h3 id="有log输出工具">有Log输出工具</h3>
<h3 id="输出运行时间类">输出运行时间类</h3>
<h1 id="完成未测试">完成未测试</h1>
<h2 id="配置表">配置表</h2>
<ol>
<li>数据读取存储[完成]</li>
<li>自动生成代码[完成]</li>
<li>生成序列化数据[完成]</li>
<li>生成代码序列化数据配置工具[完成]</li>
<li>PC/Android/Ios各个平台测试[未完成]</li>
<li>测试[未完成]</li>
</ol>
<h1 id="进行中">进行中</h1>
<h2 id="ui">UI</h2>
<ol>
<li>界面生命周期[部分]
<ol>
<li>初始化</li>
<li>enter动画</li>
<li>显示界面</li>
<li>exit动画</li>
<li>隐藏界面</li>
<li>销毁界面</li>
</ol>
</li>
<li>界面切换缓存策略[未完成]</li>
<li>红点系统[部分]</li>
<li>强制引导系统[未完成]</li>
</ol>
<h2 id="assetbundle">AssetBundle</h2>
<ol>
<li>打AssetBundle工具[部分]
<ol>
<li>选定哪些资源打到哪个Bundle里面</li>
<li>Bundle的一些配置</li>
</ol>
</li>
<li>依赖查询工具[部分]</li>
<li>生成AssetBundle的加密和解密[未]</li>
</ol>
<h2 id="资源加载">资源加载</h2>
<ol>
<li>AssetBundle加载[未]
<ol>
<li>LZMA压缩模式</li>
<li>LZ4和未压缩模式</li>
</ol>
</li>
<li>Resources加载[未]</li>
<li>编辑器下模拟AssetBundle加载[未]</li>
<li>冗余缓存的清理[未]</li>
</ol>
<p>#未开始</p>
<h2 id="启动流程">启动流程</h2>
<h2 id="网络部分">网络部分</h2>
<ol>
<li>HTTP连接</li>
<li>TCP连接</li>
<li>UDP连接</li>
</ol>
<h2 id="本地数据保存加载">本地数据保存加载</h2>
<h2 id="本地化">本地化</h2>
<h2 id="常用的shader效果">常用的Shader效果</h2>
<h2 id="其他插件工具">其他插件工具</h2>
<ol>
<li>摇杆（这个应该有插件，找个好用的集成进来）</li>
</ol>
<h2 id="其他编辑器工具这部分工具随时想到随时添加">其他编辑器工具（这部分工具随时想到随时添加）</h2>
<ol>
<li>噪声图生成工具</li>
<li>渐变采样图生成工具</li>
<li>随机地形生成工具</li>
<li>随机地牢生成工具</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[表面着色器中的结构体]]></title>
        <id>https://singledigit9.github.io/post/biao-mian-zhao-se-qi-zhong-de-jie-gou-ti/</id>
        <link href="https://singledigit9.github.io/post/biao-mian-zhao-se-qi-zhong-de-jie-gou-ti/">
        </link>
        <updated>2020-05-30T14:27:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="input">Input</h1>
<figure data-type="image" tabindex="1"><img src="https://singledigit9.github.io/post-images/1590848930611.jpeg" alt="" loading="lazy"></figure>
<h1 id="surfaceoutput">SurfaceOutPut</h1>
<p><img src="https://singledigit9.github.io/post-images/1590849021066.jpeg" alt="" loading="lazy"><br>
<img src="https://singledigit9.github.io/post-images/1590849027972.jpeg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Unity Shader 入门精要》读书笔记（扩展篇）]]></title>
        <id>https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-kuo-zhan-pian/</id>
        <link href="https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-kuo-zhan-pian/">
        </link>
        <updated>2020-05-19T18:18:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第17章-unity表面着色器探秘">第17章 Unity表面着色器探秘</h1>
<ol>
<li>表面着色器，实际上是Unity在基本的顶点片元着色器上进行的一次封装。在实际运行过程中，会自动转换成对应的顶点片元着色器来运行。</li>
<li>表面着色器的好处在于，可以方便的处理光照等效果。相同的光照效果用表面着色器实现，需要写的代码会比顶点片元着色器少好多。但它的缺点在于，一是自由度受到一些限制，有些特殊效果表面着色器实现不了；二是性能消耗一般都比较大。</li>
<li>表面着色器的计算步骤
<ol>
<li>将CGPROGRAM和ENDCG中的代码进行复制</li>
<li>生成顶点着色器输出结构体v2f_surf，用于顶点着色器和片元着色器之间数据传递。</li>
<li>生成顶点着色器。</li>
<li>生成片元着色器。</li>
<li>颜色叠加。</li>
<li>最后的颜色修改函数。<br>
<img src="https://singledigit9.github.io/post-images/1590849115208.jpeg" alt="" loading="lazy"></li>
</ol>
</li>
</ol>
<h1 id="第18章-基于物理的渲染">第18章 基于物理的渲染</h1>
<ol>
<li>Unity的Standard是金属工作流，Specularsetup是高光反射工作流。两种Shader都能调出相同的效果，只是有些参数不一样。</li>
<li>伽马校正：
<ol>
<li>原理是人们对明亮部分的光线变化的敏感程度远远低于暗的部分的敏感程度。比如，一个房间开一盏灯到开两盏灯和开99盏灯到开100盏灯给人的感觉是不同的。</li>
<li>伽马矫正是为了更加充分的利用图像的存储空间，将不明显的明亮部分压缩，将变化明显的暗的部分放大以存储更精细的值。</li>
<li>伽马校正下，显示整体偏暗。</li>
</ol>
</li>
<li>PBS（基于物理的渲染）优点在于，相当大的一部分物体，可以使用同一套shader来进行渲染，而且不用各种调参。缺点在于使用起来比较复杂，而且消耗来说也比较高。</li>
</ol>
<h1 id="第19章-unity5更新了什么">第19章 Unity5更新了什么</h1>
<p>现在版本都2019了，这章好多东西应该都不适用了，更详细的应该查unity的更新文档了。但还是简单记录一下，万一遇到类似的问题能够快速反应过来。</p>
<ol>
<li>表面着色器报错。
<ol>
<li>通常是因为转换着色器时使用了一些额外的效果计算，比如法线，光照之类的。从而导致需求的寄存器数目超过限定的寄存器数目。</li>
<li>解决办法
<ol>
<li>可以将默认的Shader Model 2.0 改为3.0，即<code>#pragma target 3.0</code>。</li>
<li>可以手动设置该着色器不计算阴影纹理坐标（不接受阴影），不计算光照纹理和雾效 ，减少额外计算。即<code>#pragma surface surfaceFunction lightModeln oshadow nolightmap nofog</code></li>
</ol>
</li>
</ol>
</li>
<li>CPU不再处理非统一缩放，也就是说，CPU会把顶点信息和非统一缩放的矩阵直接传给Shader。因此在顶点片元着色器中变换顶点法线时，需要注意非统一缩放的影响，也要注意对变换后的法线进行手动归一化操作。</li>
<li>固定管线Shader被放弃。</li>
</ol>
<h1 id="第20章-还有更多内容么">第20章 还有更多内容么</h1>
<ol>
<li>OpenGL
<ol>
<li>红宝书：《OpenGL编程指南》</li>
<li>蓝宝书：《OpenGL超级宝典》</li>
</ol>
</li>
<li>GPU精粹系列</li>
<li>叶劲峰 ，计算机图形：入门/API类；Gems类</li>
<li>GPU Pro系列和ShaderX系列</li>
<li>物理渲染和光线追踪：《Physically based rendering : From theory to implementation》</li>
<li>学术会议（Ke-Sen Huang主页上有历年的论文）
<ol>
<li>SIGGRAPH</li>
<li>SIGGRAPH Asia</li>
<li>Eurographics</li>
<li>Symposium On Interactive 3D Graphics And Games</li>
</ol>
</li>
<li>Shadertoy网站</li>
<li>GLSL SandBox Gallery网站</li>
</ol>
<h1 id="后记">后记</h1>
<p>算是终于完整看完了一遍吧。感觉自己对着色器这块确实了解的更加深入了。有一些以前一知半解的东西知道是怎么回事了。比如说伽马空间之类的。<br>
此外就是觉得自己做的练习还是比较少，而且仅仅是记笔记的话也不是很方便以后自己翻笔记查阅。因此准备在gitbook上专门弄一个shader的资料库。算是复习和继续深入学习兼而有之吧。<br>
预备Shader资料库的大致结构分为基础知识部分，数学部分，算法公式部分，代码块部分，各种常见效果和自我研究的效果的实例部分。<br>
内容很多，希望能够在今年内把基本的内容填充完毕吧。<br>
也希望资料库完成后能给自己和其他需要的同学提供帮助。<br>
--2020.05.30 23:13</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Unity Shader入门精要》读书笔记（高级篇）]]></title>
        <id>https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-gao-ji-pian/</id>
        <link href="https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-gao-ji-pian/">
        </link>
        <updated>2020-05-16T15:22:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第12章-屏幕后处理效果">第12章 屏幕后处理效果</h1>
<h2 id="脚本api">脚本API</h2>
<ol>
<li>相机脚本中使用的API</li>
</ol>
<pre><code class="language-c_sharp">Monobehavior.OnRenderImage(RenderTexture src, RenderTexture dest){}

Graphics.Blit(Texture src, RenderTexture dest);
Graphics.Blit(Texture src, RenderTexture dest,  Material mat, int pass =  -1);
Graphics.Blit(Texture src, Material mat, int pass = -1);
</code></pre>
<ol start="2">
<li>参数说明
<ol>
<li>src：源纹理</li>
<li>mat：使用的材质</li>
<li>dest：目标渲染纹理。为Null则直接将结果显示在屏幕上</li>
<li>pass：默认-1，表示会依次执行Shader中所有的Pass，否则只执行指定索引的Pass</li>
</ol>
</li>
<li><code>ImageEffectOpaque</code>：可以控制OnRenderImage执行的位置。比如当只想后处理不透明物体时，设置这个属性，使OnRenderIamge在不透明物体渲染完毕后立即调用。</li>
</ol>
<h2 id="应用">应用</h2>
<ul>
<li>屏幕后处理的标配 <code>ZTest Always Cull Off ZWrite Off</code></li>
</ul>
<h3 id="调节屏幕亮度饱和度和对比度">调节屏幕亮度，饱和度和对比度</h3>
<ol>
<li>亮度：颜色 * 亮度值</li>
<li>饱和度：</li>
</ol>
<pre><code class="language-shader">fixed4 color = tex2D(_MainTex, i.uv)
fixed temp = 0.2125 * color.r + 0.7154 * color.g + 0.0721  * color.b;
fixed tempColor = fixed(temp, temp, temp);
color = fixed4(lerp(tempColor, color.rgb, 饱和度值), color.a);
</code></pre>
<ol start="3">
<li>对比度：</li>
</ol>
<pre><code class="language-shader">color = (lerp(fixed3(0.5, 0.5, 0.5), color.rgb, 对比度值), color.a);
</code></pre>
<h3 id="边缘检测">边缘检测</h3>
<ol>
<li>常见的边缘检测算子<br>
<img src="https://singledigit9.github.io/post-images/1589705801787.jpeg" alt="" loading="lazy"></li>
<li>梯度计算
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><msqrt><mrow><msubsup><mi>G</mi><mi>x</mi><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>G</mi><mi>y</mi><mn>2</mn></msubsup></mrow></msqrt></mrow><annotation encoding="application/x-tex">G=\sqrt{G_x^2 + G_y^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.84em;vertical-align:-0.6765000000000001em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1635em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7401079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.1235em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.8800000000000001em;"><svg width='400em' height='1.8800000000000001em' viewBox='0 0 400000 1944' preserveAspectRatio='xMinYMin slice'><path d='M1001,80H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,
572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,
-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39
c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60
s208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,
-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5c4,-6.7,10,-10,18,-10z
M1001 80H400000v40H1013z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6765000000000001em;"><span></span></span></span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><mi mathvariant="normal">∣</mi><msub><mi>G</mi><mi>x</mi></msub><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><msub><mi>G</mi><mi>y</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">G = |G_x| + |G_y|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span></li>
</ol>
</li>
</ol>
<h3 id="高斯模糊">高斯模糊</h3>
<ol>
<li>高斯模糊卷积核<br>
<img src="https://singledigit9.github.io/post-images/1589706552526.jpeg" alt="" loading="lazy"></li>
<li><code>RenderTexture.GetTemporary</code>：获取一个缓存RenderTexture</li>
<li><code>RenderTexture.ReleaseTemporary</code>：释放缓存RenderTexture</li>
</ol>
<h3 id="bloom效果">Bloom效果</h3>
<ol>
<li>原理：根据阈值提取出较亮的区域，存在一个RenderTexture中，然后对它进行模糊，模拟光线扩散。最后将RenderTexture与原图向混合。</li>
<li>阈值提取</li>
</ol>
<pre><code class="language-shader">fixed luminance(fixed4 color) {
    return  0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b; 
}

fixed4 fragExtractBright(v2f i) : SV_Target {
    fixed4 c = tex2D(_MainTex, i.uv);
    fixed val = clamp(luminance(c) - _LuminanceThreshold, 0.0, 1.0);
    
    return c * val;
}
</code></pre>
<h3 id="运动模糊">运动模糊</h3>
<ol>
<li><code>RenderTexture.MarkRestoreExpected</code>：标记这个RenderTexture需要还原操作，避免Unity警告。</li>
<li>原理：
<ol>
<li>将多个图像进行叠加</li>
<li>使用速度缓存，根据速度来决定模糊采样的大小和方向</li>
</ol>
</li>
<li>书中使用的方法是在同一个RenderTexture上叠加图像来实现的。但速度过快时，会明显看到单帧的图像。</li>
</ol>
<h1 id="第13章-使用深度和法线纹理">第13章 使用深度和法线纹理</h1>
<ol>
<li>深度纹理本质上是一张渲染纹理，它存储的是深度值而不是颜色值。范围是 [0, 1]</li>
<li>深度值和NDC空间z坐标对应关系：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>=</mo><msub><mi>z</mi><mrow><mi>n</mi><mi>d</mi><mi>c</mi></mrow></msub><mo>∗</mo><mn>0.5</mn><mo>+</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">d =  z_{ndc} *  0.5 +  0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span></span></li>
<li>Unity得到深度纹理的流程
<ol>
<li>延迟渲染路径时，因为延迟渲染会把深度信息法线信息渲染都G-Buffer中，所以深度纹理和能够直接冲G-Buffer中获取，深度法线纹理一样简单合并一下就可以得到。</li>
<li>无法直接获取时，深度和法线纹理是通过单独的Pass来渲染获取的。Unity会使用<strong>着色器替换</strong>技术来选择那些渲染类型为<code>Opaque</code>的物体，判断它们的渲染队列是不是小于2500（包含BackGround，Geometry，AlphaTest），如果满足条件，则建起渲染到深度纹理中。因此，要想获得争取的深度纹理，就需要设置正确的<code>RenderType</code>。
<ol>
<li>Unity调用ShadowCaster的Pass来渲染深度纹理，因此，如果物体的Shader中不包含这个Pass，，那么这个物体就不会出现在深度纹理中。</li>
<li>Unity可以设置只渲染深度纹理还是渲染深度法线纹理。</li>
<li>因为前向渲染默认不创建深度缓存，所以Unity底层使用了额外的Pass来额外渲染。这个Pass在<code>/DefaultResources/Camera-DepthNormalTexture.shader</code>中。</li>
</ol>
</li>
</ol>
</li>
<li>深度纹理通常是24位或者16位。深度法线纹理通常是32位，其中法线存储在RG中，深度存储在BA中。</li>
<li>具体的获取
<ol>
<li>C#脚本中的API：<code>camera.depthTextureMode</code></li>
<li>Shader中声明的贴图：<code>_CameraDepthTexture</code>和<code>_CameraDepthNormalTexture</code>。</li>
<li>Shader中的采样
<ol>
<li>一般来说直接用tex2D就可以，但可能某些平台会不适用。</li>
<li>使用Unity内置的宏<code>float d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i,uv);</code></li>
<li>类似的还有<code>float d = SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(i.scrPos))</code>
<ol>
<li>第二个参数通常是由顶点着色器输出插值而得到的屏幕坐标。<code>i.scrPos = ComputeScreenPos(o.pos)</code></li>
<li>采样计算过程，使用前两个分量除以最后一个分量。</li>
</ol>
</li>
<li><code>DecodeDepthNormal(float4 depthNormalTexColor, out float depth, out float3 normal)</code>
<ol>
<li>需要注意返回的法线是视角空间下的法线方向。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>运动模糊
<ol>
<li>使用速度映射。通过深度纹理为每个像素计算其世界空间下的位置。并与前一帧的位置做差值，从而得到速度。好处是能够在一个屏幕后处理中完成整个效果，缺点就是性能消耗比较大。</li>
</ol>
</li>
<li>雾效
<ol>
<li>公式：<code>float3 afterFog = f * fogColor + (1 - f) * origColor</code>
<ol>
<li>雾效系数<code>f</code>的计算公式
<ol>
<li>线性：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>=</mo><mo>(</mo><msub><mi>d</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><mi mathvariant="normal">∣</mi><mi>z</mi><mi mathvariant="normal">∣</mi><mo>)</mo><mi mathvariant="normal">/</mi><mo>(</mo><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">f = (d_{max} - |z|)/({d_{max} - d_{min}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord">∣</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>指数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>d</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>z</mi><mi mathvariant="normal">∣</mi></mrow></msup></mrow><annotation encoding="application/x-tex">f = e^{-d*|z|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">d</span><span class="mbin mtight">∗</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mord mtight">∣</span></span></span></span></span></span></span></span></span></span></span></span></li>
<li>指数平方：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mo>(</mo><mi>d</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>z</mi><mi mathvariant="normal">∣</mi><msup><mo>)</mo><mn>2</mn></msup></mrow></msup></mrow><annotation encoding="application/x-tex">f = e^{-(d*|z|)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9869199999999998em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999998em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">d</span><span class="mbin mtight">∗</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mord mtight">∣</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="第14章-非真实感渲染">第14章 非真实感渲染</h1>
<h2 id="卡通风格渲染">卡通风格渲染</h2>
<h3 id="轮廓线">轮廓线</h3>
<ol>
<li>基于观察角度和法线：简单快速，但局限性很大，描边效果不好。</li>
<li>使用两个Pass，一个渲染背面，一个渲染正面。背面用纯色渲染稍微大一圈，组合到一起就是描边效果了。但这种方式仅仅适用于轮廓平滑的模型，不适用于立方体这类的模型。</li>
<li>基于图像处理的轮廓线渲染。使用算子进行边缘检测。适用范围广，效果较好。但一些深度法线变化小的轮廓可能无法检测出来。</li>
<li>基于轮廓边检测的轮廓线检测。原理是检测相邻的两个三角面的朝向是否不一致（是不是一个朝前一个朝后），如果不一致则两个三角面之间有一条轮廓线。但这种方式也有缺点，一个是实现复杂，另一个是动画在帧与帧之间不连贯。
<ol>
<li>公式：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>n</mi><mn>0</mn></msub><mo separator="true">⋅</mo><mi>v</mi><mo>&gt;</mo><mn>0</mn><mo>)</mo><mo>!</mo><mo>=</mo><mo>(</mo><msub><mi>n</mi><mn>1</mn></msub><mo separator="true">⋅</mo><mi>v</mi><mo>&gt;</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(n_0 · v &gt; 0) != (n_1 · v &gt; 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></li>
</ol>
</li>
</ol>
<h3 id="高光">高光</h3>
<p>卡通的高光相比于一般的高光来说，颜色过度更贱&quot;生硬&quot;。因此我们将普通的高光公式所求的的值，与一个阈值进行比较，小于该阈值直接为0，大于该阈值直接为1.</p>
<h2 id="素描风格渲染">素描风格渲染</h2>
<ol>
<li>使用了色调艺术映射的技术。</li>
<li>根据观察方向和法线的点积值，if判断，来确定使用那个贴图的素材。从而叠加渲染。</li>
</ol>
<h1 id="第15章-使用噪声">第15章 使用噪声</h1>
<ol>
<li>消融效果：在噪声图上采样，得到噪声值。然后将当前颜色值与噪声值进行比较，大于或者小于的直接将该片元discard。剩余的片元再次处理一下边缘颜色就可以了。</li>
<li>水波效果：基于时间，在法线噪声图上采样。用采样得到的法线值，计算颜色偏移等。</li>
<li>烟雾飘动的效果。</li>
</ol>
<h1 id="第16章-unity中的渲染优化技术">第16章 Unity中的渲染优化技术</h1>
<p>首要规则：过度优化和不优化一样严重。</p>
<p>此外有一篇关于Unity优化的导图文章特别好，写的很全。基本上按照那个导图一个流程走下来，性能应该没什么大问题。但因为那个导图是收费的，这里不好直接贴上来。放一个链接，有兴趣可以去查看。</p>
<p><a href="https://mm.edrawsoft.cn/store">在线思维导图(在搜索里搜Unity就能找到了)</a></p>
<h2 id="移动平台的特点">移动平台的特点</h2>
<ol>
<li>移动设备一般使用基于Tile的延迟渲染架构，即将图像装入一个个tile中。然后再由硬件选择将tile中的哪个图像渲染到屏幕上。</li>
<li>基于上面描述的渲染架构的特点，overDraw（就是一个像素被多次绘制）很有可能是性能瓶颈。</li>
</ol>
<h2 id="影响性能的因素">影响性能的因素</h2>
<ol>
<li>CPU
<ol>
<li>draw Call</li>
<li>逻辑</li>
<li>物理</li>
</ol>
</li>
<li>GPU
<ol>
<li>顶点
<ol>
<li>顶点过多</li>
<li>顶点计算过多</li>
</ol>
</li>
<li>片元
<ol>
<li>过多的片元</li>
<li>逐片元计算过多</li>
</ol>
</li>
</ol>
</li>
<li>带宽
<ol>
<li>尺寸过大的未压缩的纹理</li>
<li>分辨率过高的帧缓存</li>
</ol>
</li>
</ol>
<h2 id="unity中的分析工具">Unity中的分析工具</h2>
<ol>
<li>
<p>渲染统计信息。Game窗口的Stats<br>
<img src="https://singledigit9.github.io/post-images/1590816549696.jpeg" alt="" loading="lazy"><br>
<img src="https://singledigit9.github.io/post-images/1590816560024.jpeg" alt="" loading="lazy"></p>
</li>
<li>
<p>Profiler<br>
可以动态查看当前帧的消耗情况。但需要注意的是，编辑器下的调试有一定的参考价值，但和真机上还是有差别。</p>
</li>
<li>
<p>帧调试器<br>
可以看每一帧都渲染了什么东西，有什么东西是应该一起渲染的但是没有一起渲染（这个对FairyGUI尤其有用。优化时FairyGUI往往调整一下层级就会减少一些DrawCall）</p>
</li>
</ol>
<h2 id="动态批处理">动态批处理</h2>
<ol>
<li>顶点数小于900。如果Shader中使用了顶点位置，法线，纹理坐标这3个顶点属性，那么就要小于300</li>
<li>同一个缩放尺度下。（书上说Unity5之后已经对这个进行了优化，但我在Unity2018下用Cube进行试验，不同缩放尺度的Cube一样会增加DrawCall，想动态批处理的话，这个最好还是严格遵守）</li>
<li>需要动态批处理的物体应该指向光照纹理的同一个位置。（<strong>光照纹理这部分接触较少，需要深入学习</strong>）</li>
<li>多Pass的Shader会中断批处理操作。</li>
</ol>
<h2 id="静态批处理">静态批处理</h2>
<p>运行开始阶段，将需要静态批处理的网格合并到一个大网格中。<br>
静态批处理相比于动态批处理更加高效，但仍然有一些缺点。</p>
<ol>
<li>静态批处理的物体不能够移动</li>
<li>往往会占用更多的内存。因为一些物体如果共享了相同的网格，合并前每一个物体都会有一个该网格的复制。最终导致一个网格的多个复制会发给GPU，从而导致性能瓶颈。
<ol>
<li>例子：1000个相同模型的树，如果使用了静态批处理，则会吧这个模型的1000的复制合并到一个大网格里进行处理。也就是说，一个树的模型，我们多消耗了999个单位的内存空间。</li>
</ol>
</li>
</ol>
<h2 id="共享材质">共享材质</h2>
<p>关键字：shareMaterial</p>
<ol>
<li>使用Renderer.Material时，会创建一份原始材质球的复制，造成额外消耗。</li>
<li>使用Renderer.ShareMaterial时，会修改原始的材质球，从而使使用这个材质球的模型都收到影响。</li>
</ol>
<h2 id="减少顶点">减少顶点</h2>
<ol>
<li>模型制作，去除不必要的顶点和边</li>
<li>LOD</li>
<li>遮挡剔除技术（<strong>这个需要重点学习一下，之前没有用过。</strong>）</li>
</ol>
<h2 id="减少片元">减少片元</h2>
<ol>
<li>减少overDraw
<ol>
<li>最最主要的，尽可能不要用半透明的渲染队列。半透明物体会破坏渲染队列。</li>
<li>对于UI，如果无法避免半透明，可以将UI的相机和其他的场景相机分开，不要一起渲染。</li>
<li>透明度测试也会影响游戏性能。discard和clip操作可能会导致一些硬件的优化策略失败。</li>
</ol>
</li>
<li>减少实时光照和阴影
<ol>
<li>灯光贴图</li>
<li>移动平台上，物体的逐像素光照光源数目应该小于1（不包括平行光）。如果为了效果需要多个光源，请使用逐顶点光照。</li>
<li>将光照计算存储到纹理中。根据光源方向，视角方向，法线方向等直接从纹理采样得到信息。但这种方法需要编写对应的美术编辑器，</li>
</ol>
</li>
</ol>
<h2 id="较少带宽">较少带宽</h2>
<ol>
<li>减少纹理大小。纹理大小应该是2的整数次幂。纹理压缩格式在不影响效果的情况下，应该压缩到最小。</li>
<li>有些设备空有高分辨率的屏幕而没有配套的其他硬件，从而导致游戏在那个设备上运行时效果不好。可以使用Screen.SetResolution来设置分辨率。（<strong>这块需要进一步查阅资料学习</strong>）</li>
</ol>
<h2 id="减少计算复杂度">减少计算复杂度</h2>
<ol>
<li>Shader中的LOD
<ol>
<li>只有Shader中的LOD小于指定值时，这个Shader才会被使用。</li>
<li>内置的Diffuse的LOD是200，BumpedSpecular是400。</li>
</ol>
</li>
<li>Shader代码
<ol>
<li>计算数目排序：物体数量 &lt; 顶点数量 &lt; 片元数量</li>
<li>尽可能把计算上移，减少计算。</li>
<li>尽可能使用低精度浮点数进行计算</li>
<li>避免不同精度数来回切换</li>
<li>避免频繁的color.rgrg操作</li>
<li>尽可能不要用屏幕后处理</li>
<li>如果需要使用屏幕后处理，尽可能把多个特效封到一个Shader里</li>
<li>尽可能不要用分支和循环，sin, tan, pow，等费时操作，以及discard操作。</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AssetBundle官方文档学习笔记]]></title>
        <id>https://singledigit9.github.io/post/assetbundle-guan-fang-wen-dang-xue-xi-bi-ji/</id>
        <link href="https://singledigit9.github.io/post/assetbundle-guan-fang-wen-dang-xue-xi-bi-ji/">
        </link>
        <updated>2020-05-13T14:14:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="文档版本地址">文档版本&amp;地址</h1>
<p>2019.3 <a href="https://docs.unity3d.com/Manual/AssetBundlesIntro.html">https://docs.unity3d.com/Manual/AssetBundlesIntro.html</a></p>
<h1 id="官方工具">官方工具</h1>
<p><a href="https://docs.unity3d.com/Packages/com.unity.addressables@1.8/manual/index.html">Unity Addressable Asset system</a><br>
<a href="https://github.com/Unity-Technologies/AssetBundles-Browser">Unity Asset Bundle Browser tool</a><br>
<a href="https://docs.unity3d.com/Manual/AssetBundles-Browser.html">Unity Asset Bundle Browser tool文档</a></p>
<h1 id="基础介绍">基础介绍</h1>
<h2 id="assetbundle的特性">AssetBundle的特性</h2>
<ul>
<li>AssetBundle能够互相依赖。例如，一个AssetBundle中的材质球能够引用另一个AssetBundle上的贴图。</li>
<li>AssetBundle能够使用Unity内置的算法进行压缩，以提高传输效率。</li>
</ul>
<h2 id="assetbundle能够做什么">AssetBundle能够做什么</h2>
<ul>
<li>DLC的更新</li>
<li>减少初始安装包大小</li>
<li>减小运行时内存压力</li>
<li>针对用户的终端（手机）加载优化资源</li>
</ul>
<h2 id="assetbundle文件和assetbundle对象">AssetBundle文件和AssetBundle对象</h2>
<ul>
<li>AssetBundle文件中包含的是打入其中的各种资源。</li>
<li>AssetBundle对象中有一个Key值为路径，Value值为对应资源的字典。</li>
</ul>
<h1 id="工作流程">工作流程</h1>
<h2 id="资源的设置">资源的设置</h2>
<ol>
<li>选中要打包的资源，在检视面板的最下面可以看到AssetBundle配置选项。</li>
<li>第一个配置：要将这个资源打进哪一个AssetBundle<strong>待测试</strong></li>
<li>第二个配置：这个资源的变体<strong>待测试</strong></li>
</ol>
<h2 id="资源的打包">资源的打包</h2>
<p>官网提供了示例代码<strong>待测试</strong></p>
<pre><code>using UnityEditor;
using System.IO;

public class CreateAssetBundles
{
    [MenuItem(&quot;Assets/Build AssetBundles&quot;)]
    static void BuildAllAssetBundles()
    {
        string assetBundleDirectory = &quot;Assets/AssetBundles&quot;;
        if(!Directory.Exists(assetBundleDirectory))
        {
            Directory.CreateDirectory(assetBundleDirectory);
        }
        BuildPipeline.BuildAssetBundles(assetBundleDirectory, 
                                        BuildAssetBundleOptions.None, 
                                        BuildTarget.StandaloneWindows);
    }
}
</code></pre>
<h2 id="加载assetbundle和assetbundle里面的资源">加载AssetBundle和AssetBundle里面的资源</h2>
<h3 id="加载本地文件">加载本地文件</h3>
<p>官网示例代码<strong>待测试</strong></p>
<pre><code>public class LoadFromFileExample : MonoBehaviour {
    function Start() {
        var myLoadedAssetBundle 
            = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, &quot;myassetBundle&quot;));
        if (myLoadedAssetBundle == null) {
            Debug.Log(&quot;Failed to load AssetBundle!&quot;);
            return;
        }
        var prefab = myLoadedAssetBundle.LoadAsset&lt;GameObject&gt;(&quot;MyObject&quot;);
        Instantiate(prefab);
    }
}
</code></pre>
<h3 id="加载网络文件">加载网络文件</h3>
<pre><code>IEnumerator InstantiateObject()
{
    string url = &quot;file:///&quot; + Application.dataPath + &quot;/AssetBundles/&quot; + assetBundleName;        
    UnityEngine.Networking.UnityWebRequest request 
        = UnityEngine.Networking.UnityWebRequest.GetAssetBundle(url, 0);
    yield return request.Send();
    AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);
    GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;);
    GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;(&quot;Sprite&quot;);
    Instantiate(cube);
    Instantiate(sprite);
}
</code></pre>
<h1 id="打包策略">打包策略</h1>
<ul>
<li>开发人员应该明确知道在什么时候什么位置使用什么资源。明确了这个问题后才能够决定使用什么打包策略。</li>
</ul>
<h2 id="依据实体打包">依据实体打包</h2>
<ul>
<li>举例：
<ul>
<li>将一个UIPrefab和它所用到的贴图打包在一起</li>
<li>将一个模型和这个模型的材质球，贴图，动画文件打包在一起</li>
<li>将一个场景和这个场景所用到的资源打包在一起</li>
</ul>
</li>
<li>特点
<ul>
<li>每个实体的AssetBundle是分开的，更新单独的实体时不用更新其他没有改变的资源</li>
</ul>
</li>
</ul>
<h2 id="依据资源类型打包">依据资源类型打包</h2>
<ul>
<li>特点
<ul>
<li>不同平台下压缩格式相同的资源AssetBundle可以在不同平台下重用</li>
</ul>
</li>
</ul>
<h2 id="选择正确的打包策略">选择正确的打包策略</h2>
<ul>
<li>AssetBundle是有依赖关系的。如果你的AssetBundle打包策略不好，可能会出现想加载一个GameObject而需要加载多个AssetBundle的情况。</li>
<li>上面两种策略当然也可以混合使用。这需要根据具体的项目需求来进行选择。</li>
</ul>
<h3 id="关键点">关键点</h3>
<ul>
<li>将经常变化的资源和很少变化的资源分开打包。</li>
<li>理清资源依赖关系，避免复杂的相互依赖。比如将通用的依赖资源移到Common中。</li>
<li>不可能同时加载使用的资源不要打进一个AssetBundle里</li>
<li>如果一个AssetBundle中只有一部分资源被频繁的加载，那么需要把这个AssetBundle进行拆分</li>
<li>将同时频繁加载的小（资源数少于5-10）的AssetBundle合并到一起。</li>
<li>不同版本的同一物体，可以考虑使用变体 <strong>变体具体是什么待测试</strong></li>
</ul>
<h1 id="打包assetbundle">打包AssetBundle</h1>
<h2 id="buildassetbundleoptions">BuildAssetBundleOptions</h2>
<ul>
<li>关于打AssetBundle的各种设置  <strong>待测试</strong></li>
</ul>
<table>
<thead>
<tr>
<th>API</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>没有特殊设置。使用LZMA进行压缩</td>
</tr>
<tr>
<td>UncompressedAssetBundle</td>
<td>不对AssetBundle进行压缩</td>
</tr>
<tr>
<td>DisableWriteTypeTree</td>
<td>AssetBundle中不包含类型信息</td>
</tr>
<tr>
<td>DeterministicAssetBundle</td>
<td>确保相同的资源打进AssetBundle里面后，哈希值不会变化</td>
</tr>
<tr>
<td>ForceRebuildAssetBundle</td>
<td>强制重新打AssetBundle</td>
</tr>
<tr>
<td>IgnoreTypeTreeChanges</td>
<td>增量打包时忽略类型树变化</td>
</tr>
<tr>
<td>AppendHashToAssetBundleName</td>
<td>将Hash值添加到AssetBundle名字之后，能够从名字直接看出AssetBundle是否有变化</td>
</tr>
<tr>
<td>ChunkBasedCompression</td>
<td>使用LZ4格式压缩</td>
</tr>
<tr>
<td>StrictMode</td>
<td>打包过程中报错则中断打包</td>
</tr>
<tr>
<td>DryRunBuild</td>
<td>Do a dry run build.</td>
</tr>
<tr>
<td>DisableLoadAssetByFileName</td>
<td>不允许使用文件名字加载资源</td>
</tr>
<tr>
<td>DisableLoadAssetByFileNameWithExtension</td>
<td>不允许使用带后缀的文件名字加载资源</td>
</tr>
<tr>
<td>AssetBundleStripUnityVersion</td>
<td>构建时删除Unity版本号</td>
</tr>
</tbody>
</table>
<h2 id="关于压缩格式">关于压缩格式</h2>
<ul>
<li>默认情况下，使用LZMA格式创建，使用LZ4格式缓存</li>
</ul>
<h3 id="压缩格式类型">压缩格式类型</h3>
<ul>
<li>LZMA：
<ul>
<li>打出的AssetBundle最小，但加载时间也会更长（加载资源之前需要先将资源所在的AssetBundle整个进行解压）。</li>
<li>资源解压后，会使用LZ4格式重新压缩。</li>
<li>推荐在初始资源下载时使用这个格式。</li>
<li>通过<code>UnityWebRequestAssetBundle</code>加载的LZMA格式的AssetBundle会自动解压并重新压缩为LZ4，缓存到本地。如果是使用其他方式下载的Assetbundle,则可以使用<code>AssetBundle.RecompressAssetBundleAsync</code>对其进行重新压缩</li>
</ul>
</li>
<li>LZ4：
<ul>
<li>加载资源前不必对整个AssetBundle进行解压</li>
<li>允许以块的形式加载资源。解压单个块，即使当前AssetBund中其他的块没有解压，也能使用当前块中的资源</li>
<li>这种压缩模式下<code>AssetBundle.LoadFromFile</code>只在内存里加载Bundle的资源目录，而不是Bundle本身</li>
</ul>
</li>
<li>完全不压缩：
<ul>
<li>文件大，加载快</li>
</ul>
</li>
</ul>
<h2 id="打包生成的文件">打包生成的文件</h2>
<ul>
<li>
<p>AssetBundle文件</p>
<ul>
<li>场景Bundle和其他一般资源Bundle里面的结构略有不同。场景的Bundle有一些特殊优化。<br>
<img src="https://singledigit9.github.io/post-images/1589379363606.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>
<p>Manifest文件</p>
<ul>
<li>包含了当前AssetBundle的资源信息以及资源的依赖信息</li>
</ul>
</li>
</ul>
<h1 id="assetbundle依赖">AssetBundle依赖</h1>
<ul>
<li>一个Bundle中的资源引用另一个Bundle中的资源会产生依赖；一个Bundle中的资源引用一个不在Bundle中的资源不会产生依赖。</li>
<li>如果Bundle中资源A引用不在Bundle中的资源B，则资源B会被复制并打进A的Bundle中。</li>
<li>如果多个Bundle中的资源引用不在Bundle中的资源B，则资源B会被复制并打进每一个Bundle中。</li>
<li>如果要加载的Bundle A中的资源依赖Bundle B，那么加载这个资源前要先将Bundle B加载好。</li>
</ul>
<h2 id="跨assetbundle的重复信息">跨AssetBundle的重复信息</h2>
<ul>
<li>如果一个Bundle中有一个预制，都引用了不在Bundle中的材质球和贴图
<ul>
<li>影响最终打出来的Bundle大小增加</li>
<li>运行时内存占用增加</li>
<li>影响Unity自动批处理。Unity把不同Bundle中的材质球都看作是唯一的。</li>
</ul>
</li>
</ul>
<h2 id="编辑器下依赖关系的查询">编辑器下依赖关系的查询</h2>
<ul>
<li><code>AssetDatabase</code>：查询依赖关系</li>
<li><code>AssetImporter</code>：查询资源分配到了哪个AssetBundle</li>
</ul>
<h2 id="几种依赖关系的处理方法">几种依赖关系的处理方法</h2>
<ul>
<li>共同的依赖资源集中到一个Bundle里面（不适用于复杂交叉依赖的情况）</li>
<li>确保同一时间，不会有任何一个Bundle有多重被依赖。（适用于基于Level的游戏，但这样做仍然会增加AssetBundle的文件大小）</li>
<li>确保所有依赖的资源都在自己的AssetBundle里面。但这样做机制比较复杂。</li>
</ul>
<h1 id="assetbundle的使用">AssetBundle的使用</h1>
<h2 id="加载assetbundle">加载AssetBundle</h2>
<ul>
<li><code>AssetBundle.LoadFromMemoryAsync</code>
<ul>
<li>从内存异步加载AssetBundle</li>
<li>参数为Bundle文件的字节流</li>
<li>使用示例：</li>
</ul>
</li>
</ul>
<pre><code>using UnityEngine;
using System.Collections;
using System.IO;

public class Example : MonoBehaviour
{
    IEnumerator LoadFromMemoryAsync(string path)
    {
        AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path));
        yield return createRequest;
        AssetBundle bundle = createRequest.assetBundle;
        var prefab = bundle.LoadAsset&lt;GameObject&gt;(&quot;MyObject&quot;);
        Instantiate(prefab);
    }
}
</code></pre>
<ul>
<li><code>AssetBundle.LoadFromFile</code>
<ul>
<li>未压缩和LZ4格式压缩的AssetBundle，会直接从硬盘中加载。加载LZMA格式的AssetBundle时，会先解压，然后再加载。</li>
<li>加载本地的未压缩资源效率很高。</li>
<li>Unity5.3以及以前版本，Android平台使用这个API加载StreamingAssets文件夹中的AssetBundle会失败。因为StreamingAssets文件夹中的内容会在一个压缩的.jar文件中。</li>
<li>Unity5.4以及更新的版本能够正常的使用这个API.</li>
<li>使用示例：</li>
</ul>
</li>
</ul>
<pre><code>public class LoadFromFileExample : MonoBehaviour {
    function Start() {
        var myLoadedAssetBundle 
            = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, &quot;myassetBundle&quot;));
        
        if (myLoadedAssetBundle == null) {
            Debug.Log(&quot;Failed to load AssetBundle!&quot;);
            return;
        }
        var prefab = myLoadedAssetBundle.LoadAsset.&lt;GameObject&gt;(&quot;MyObject&quot;);
        Instantiate(prefab);
    }
}
</code></pre>
<ul>
<li><code>UnityWebRequest</code>
<ul>
<li>相当于原来的<code>WWW</code>类的升级版。</li>
<li>能够方便的处理下载以及HTTP的Get/POST请求。</li>
<li>使用示例：</li>
</ul>
</li>
</ul>
<pre><code>IEnumerator InstantiateObject()
{
    string uri = &quot;file:///&quot; + Application.dataPath + &quot;/AssetBundles/&quot; + assetBundleName; 
    UnityEngine.Networking.UnityWebRequest request 
        = UnityEngine.Networking.UnityWebRequest.GetAssetBundle(uri, 0);
    yield return request.Send();
    AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);
    GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;);
    GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;(&quot;Sprite&quot;);
    Instantiate(cube);
    Instantiate(sprite);
}
</code></pre>
<ul>
<li><code>WWW.LoadFromCacheOrDownload</code>[已淘汰，直接跳过]</li>
</ul>
<h2 id="加载assetbundle中的资源">加载AssetBundle中的资源</h2>
<ul>
<li><code>T objectFromBundle = bundleObject.LoadAsset&lt;T&gt;(assetName);</code></li>
<li><code>Unity.Object[] objectArray = loadedAssetBundle.LoadAllAssets();</code></li>
<li></li>
</ul>
<pre><code>AssetBundleRequest request = loadedAssetBundleObject.LoadAssetAsync&lt;GameObject&gt;(assetName);
yield return request;
var loadedAsset = request.asset;
</code></pre>
<ul>
<li></li>
</ul>
<pre><code>AssetBundleRequest request = loadedAssetBundle.LoadAllAssetsAsync();
yield return request;
var loadedAssets = request.allAssets;
</code></pre>
<h2 id="加载manifest文件">加载Manifest文件</h2>
<ul>
<li>加载Manifest文件是为了解决依赖问题</li>
<li>加载Manifest文件的示例代码</li>
</ul>
<pre><code>AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);
AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;);
</code></pre>
<ul>
<li>查询并加载依赖的示例代码</li>
</ul>
<pre><code>AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);
AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;);
string[] dependencies = manifest.GetAllDependencies(&quot;assetBundle&quot;); //Pass the name of the bundle you want the dependencies for.
foreach(string dependency in dependencies)
{
    AssetBundle.LoadFromFile(Path.Combine(assetBundlePath, dependency));
}
</code></pre>
<h1 id="管理加载的assetbundle">管理加载的AssetBundle</h1>
<ul>
<li>不正确的卸载AssetBundle可能导致复制内存中的object或者其他问题，比如贴图丢失。</li>
</ul>
<h2 id="assetbundleunloadbool"><code>AssetBundle.Unload(bool)</code></h2>
<ul>
<li>卸载AssetBundle的头部信息</li>
</ul>
<h3 id="参数详细说明">参数详细说明</h3>
<ul>
<li>参数为true时 也卸载AssetBundle所有的实例化对象，这个实例化对象不包含对象的复制（复制的资源不是AssetBundle里面的资源）。</li>
<li>多数情况下，会使用true来保证内存中没有重复的对象</li>
<li>如果参数必须为false的话，内存中无法访问的资源只能通过以下方式卸载
<ul>
<li>手动调用<code>Resources.UnloadUnusedAssets</code></li>
<li>非添加方式加载场景，会自动调用<code>Resources.UnloadUnusedAssets</code></li>
</ul>
</li>
</ul>
<h4 id="详细例子">详细例子</h4>
<ul>
<li>从AssetBundle中加载的一个GameObject资源，true卸载时，会把这个GameObject资源卸载掉，而不会把Instantiate的GameObject也卸载掉。</li>
<li>现在从AssetBundle中加载一个材质球在活动场景中使用
<ul>
<li>使用Unload(true)卸载时，材质球在场景中的所有实例一样会被卸载和销毁。<strong>这里有个疑问待测试：Instantiate的材质球会不会也被销毁</strong></li>
<li>使用Unload(false)卸载时，会打断当前材质球和AssetBundle的链接。如果AssetBundle重新加载，它并不会链接到已经存在的材质球。此时加载该材质球时，会复制一个新的。</li>
</ul>
</li>
</ul>
<p><img src="https://singledigit9.github.io/post-images/1589379410371.png" alt="" loading="lazy"><br>
<img src="https://singledigit9.github.io/post-images/1589379417761.png" alt="" loading="lazy"><br>
<img src="https://singledigit9.github.io/post-images/1589379424865.png" alt="" loading="lazy"></p>
<h2 id="保证资源不重复的方法">保证资源不重复的方法</h2>
<ul>
<li>在恰当的时机卸载暂时加载的AssetBundle，比如Loading时</li>
<li>记录资源加载的引用计数，避免重复加载资源和异常卸载资源</li>
</ul>
<h1 id="assetbundle缓存">AssetBundle缓存</h1>
<ul>
<li>Unity维护两个缓存，分别是内存缓存和硬盘缓存。</li>
<li>将AssetBundle中加载到内存中，会消耗大量的内存空间。除非有特别频繁快速访问AssetBundle中内容的需求，否则请使用磁盘缓存。</li>
<li>如果你向<code>UnityWebRequest</code>提供了一个版本参数（版本号挥着Hash），Unity会将AssetBundle数据存储到本地硬盘。如果不提供参数，Unity将会使用内存缓存。</li>
<li><code>Caching.compressionEnabled</code>设置为true时，存储到本地的AssetBundle文件会以LZ4的格式进行压缩；设置为false时，则存储到本地的文件不会压缩。</li>
<li>使用LZMA格式初始加载会耗费比较长的时间。因为它需要先解压，然后以指定格式存储到硬盘缓存。之后加载会直接使用缓存来加载。</li>
<li>推荐使用<code>UnityWebRequest</code>，因为<code>AssetBundle.LoadFromFile</code>和<code>AssetBundle.LoadFromFileAsync</code>加载LZMA后会使用内存中的缓存。如果不能使用<code>UnityWebRequest</code>，可以使用<code>AssetBundle.RecompressAssetBundleAsync</code>手动将AssetBundle数据写到硬盘缓存上。</li>
<li>内部测试表明，使用磁盘缓存和内存缓存存在着一个数量级的差异。需要根据项目的需求自己权衡。</li>
</ul>
<h2 id="缓存类型">缓存类型</h2>
<ol>
<li>内存缓存：AssetBundle为不压缩格式</li>
<li>硬盘缓存：在可写空间以指定格式压缩保存AssetBundle文件</li>
</ol>
<h1 id="assetbundle补丁">AssetBundle补丁</h1>
<ul>
<li>下载一个新的AssetBundle来替换现有的AssetBundle</li>
<li>使用<code>UnityWebRequest</code>API时，会根据传入的版本参数自动触发下载新的AssetBundle</li>
<li>Unity使用固定方式生成AssetBundle文件，也就是说，资源不变，生成的AssetBundle也是不变的。正因为这样，可以自定义下载器来区分补丁差异。</li>
<li>Unity内部并没有实现差分补丁的功能，如果有差分补丁的需求的话，需要手动实现。（差分补丁：新AssetBundle和旧AssetBundle进行比较生成补丁。客户端下载补丁并经过处理生成新AssetBundle）</li>
</ul>
<h2 id="如何确定要替换的assetbundle">如何确定要替换的AssetBundle</h2>
<ul>
<li>从服务器获取要下载的资源列表和版本信息。和本地的资源列表版本信息做对比。如果本地资源缺失或者版本号不对，则需要下载替换这个AssetBundle。</li>
<li>也可以自定义系统来检测AssetBundle变化，比如MD5，JSON等。</li>
</ul>
<h1 id="常见问题">常见问题</h1>
<h2 id="自动生成的图集">自动生成的图集</h2>
<ul>
<li>如果一个图集的所有sprite都打进同一个Bundle，则自动生成的图集将会打进这个Bundle。</li>
<li>如果sprite被打进多个Bundle，那么图集会复制多分分别打进对应的Bundle。</li>
<li>如果sprite没有被打进Bundle，那么图集也不会被打进Bundle</li>
<li>Unity5.2.2p3以及以前的版本对图集打Bundle的支持有问题。</li>
</ul>
<h2 id="android-texture">Android Texture</h2>
<ul>
<li>Android设备碎片化问题严重，需要将贴图压缩成对应的格式。</li>
<li>ETC1没有透明通道，但基本上所有设备都支持</li>
<li>ETC2，旧设备可能不支持</li>
<li>可以使用变体，将不同变体的贴图分别打在一个AssetBundle里面，根据情况进行加载。（需要贴图设置正确）</li>
<li><code>SystemInfo.SupportedTextureFormat</code>可以使用这个API来检测设备支持什么格式的贴图</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity Shader的内置时间变量]]></title>
        <id>https://singledigit9.github.io/post/unity-shader-de-nei-zhi-shi-jian-bian-liang/</id>
        <link href="https://singledigit9.github.io/post/unity-shader-de-nei-zhi-shi-jian-bian-liang/">
        </link>
        <updated>2020-05-05T11:06:44.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://singledigit9.github.io/post-images/1588676867160.jpeg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Unity Shader 入门精要》读书笔记（中级篇共三章）]]></title>
        <id>https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-zhong-ji-pian/</id>
        <link href="https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-zhong-ji-pian/">
        </link>
        <updated>2020-05-04T07:49:40.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="写在前面">写在前面</h3>
<p>有不少地方不好理解，需要仔细研究</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="写在前面">写在前面</h3>
<p>有不少地方不好理解，需要仔细研究</p>
<!-- more -->
<h3 id="第九章-更复杂的光照">第九章 更复杂的光照</h3>
<p>Shader中的渲染路径设置写在另一篇文章里面，方便查阅。</p>
<h4 id="unity中的渲染路径">Unity中的渲染路径</h4>
<ol>
<li>
<p>Unity中渲染路径的设置</p>
<ol>
<li>全局的渲染路径设置：Other Setting--&gt;Rendering Path</li>
<li>特殊的渲染路径设置：Camera的检视面板上的Rendering Path</li>
<li>需要注意的是，如果当前显卡不支持当前的渲染路径，Unity则会自动使用更低一级的渲染路径。比如，一个GPU不支持延迟路径，则Unity会自动使用前向路径。</li>
</ol>
</li>
<li>
<p>渲染路径的类型</p>
<ol>
<li>
<p>前向渲染：传统的渲染方式，也是最常用的渲染方式。当场景中有大量的实时光源时，性能会极速下降。</p>
<ol>
<li>基本任务：渲染每个渲染图元，并且计算颜色缓冲区和深度缓冲区的信息。</li>
<li>大致步骤：每次前向渲染，对于每一个片元，都会进行深度测试。如果没有通过测试，则直接将该片元丢弃；如果通过深度测试，则片元进行正常的一系列计算最终更新颜色缓冲区。</li>
<li>每一个逐像素光源，都会执行上面的步骤。如果一个物体在多个逐像素光源下，那么这个物体就要执行多个 Pass，每个Pass的光照结果进行混合，来得到最终的颜色值。</li>
<li>一般而言引擎会限制逐像素光照的数目。</li>
<li>Unity中前向渲染光照的3种处理方式
<ol>
<li>逐顶点</li>
<li>逐像素</li>
<li>球协函数（SH）：拓展文章<a href="https://huailiang.github.io/blog/2019/harmonics/"><em>球谐光照</em></a></li>
</ol>
</li>
<li>Unity中光源使用哪种渲染方式的依据
<ol>
<li>最亮的平行光按照逐像素处理</li>
<li>RenderMode设置成Important的光源会逐像素处理</li>
<li>RenderMode设置成Not Important的光源会逐顶点或者SH处理</li>
<li>如果根据以上规则得到的逐像素处理的光源数量少于QualitySetting中Pixel Light Count，则会有更多的光源按照逐像素处理。</li>
</ol>
</li>
<li>前向渲染的Shader实现<br>
<img src="https://singledigit9.github.io/post-images/1588580937528.jpeg" alt="" loading="lazy">
<ol>
<li>上图中两个编译指令必不可少，否则可能得到光照相关的值不正确。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>延迟渲染：</p>
<ol>
<li>原理：
<ol>
<li>第一个Pass不进行任何光照计算，仅仅计算那些片元是可见的。当一个片元是可见的，就将那个片元的颜色，平滑度，法线，自发光等信息存储到G缓冲区中。对于每个 物体来说，这个Pass只会执行一次。</li>
<li>第二个Pass，读取G缓冲区中的片元信息，比如表面法线，视角方向等，来进行光照计算。</li>
</ol>
</li>
<li>优点：
<ol>
<li>适合场景中光源很多，前向渲染会造成性能瓶颈的时候使用。</li>
<li>每个光源 都能够逐像素渲染</li>
</ol>
</li>
<li>缺点：
<ol>
<li>不支持真正的抗锯齿功能</li>
<li>不能处理半透明物体</li>
<li>对显卡有要求，要求支持MRT（Multiple Render Targets），Shader  Model 3.0以及以上，深度渲染纹理以及双面的模版缓冲。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>顶点照明渲染（这个新版Unity逐渐不再支持，暂时不研究了 。）</p>
</li>
</ol>
</li>
</ol>
<h4 id="光源">光源</h4>
<ol>
<li>光源的5个属性：位置，方向，颜色，强度，衰减</li>
<li>Unity中实时光源的几种类型
<ol>
<li>平行光</li>
<li>点光源</li>
<li>聚光灯</li>
</ol>
</li>
<li>Shader中区分光源
<ol>
<li>平行光：<code>#ifdef USING_DIRECTIONAL_LIGHT</code></li>
<li>点光源：<code>#if defined (POINT)</code></li>
<li>聚光灯：<code>defined (SPOT)</code></li>
</ol>
</li>
</ol>
<h4 id="unity的光照衰减">Unity的光照衰减</h4>
<ol>
<li>使用衰减纹理：Unity默认方式。一般而言，性能提升，效果大部分是良好的。
<ol>
<li>优点：计算简单</li>
<li>缺点：
<ol>
<li>需要预先采样纹理，&amp;纹理大小也会影响衰减精度</li>
<li>不直观，且一旦使用就无发使用其他的公式</li>
</ol>
</li>
<li>Shader中纹理的关键字：_LightTexture0（如果光源使用了cookies，那么应该使用_LightTextureB0）</li>
</ol>
</li>
</ol>
<h4 id="阴影">阴影</h4>
<ol>
<li>阴影是如何实现的
<ol>
<li>Shadow Map：将摄像机位置与 光源位置重合，那么摄像机看不到的地方就是应该显示阴影的地方。（Unity使用的是这种技术）</li>
</ol>
</li>
<li>前向渲染中，如果平行光开启了阴影，则Unity会为光源计算它的阴影映射纹理。这个纹理是一张 深度图，记录了从光源位置出发，能看到的场景中最近的表面位置（深度信息）。
<ol>
<li>如何记录表面位置信息
<ol>
<li>将摄像机放到光源位置，然后走正常的渲染流，得到深度信息。（但这种方式有性能浪费）</li>
<li>使用特殊的Pass，Tag标记LightMode为ShadowCaster。</li>
</ol>
</li>
<li>如何判定一个点在阴影里面：将点转换到光源空间下，对阴影纹理进行采样，如果采样的深度小于该点的深度，则这个点在阴影里面。</li>
</ol>
</li>
<li>Unity是如何显示最终的阴影的
<ol>
<li>屏幕空间的阴影映射技术（需要显卡支持，有些移动平台不支持这种特性）（原本是延迟渲染的阴影方法）</li>
<li>步骤：
<ol>
<li>调用ShadowCaster的Pass，生成光源的阴影纹理和摄像机的深度纹理</li>
<li>根据上面两个纹理生成屏幕空间的阴影图。如果摄像机的深度图中记录的表面深度大于转换到阴影映射纹理中的深度值，则说明表面虽然是可见的，但处于阴影中。</li>
</ol>
</li>
</ol>
</li>
<li>物体之间阴影的显示
<ol>
<li>想要接收：需要对阴影映射纹理进行采样，将采样的结果与最后的光照结果相乘。</li>
<li>想要投射：将物体加入到光源的阴影映射纹理计算中。（ShadowCaster的Pass）</li>
</ol>
</li>
<li>Unity中阴影的设置
<ol>
<li>Light检视面板：ShadowType选项，可以决定当前光源是否开启阴影</li>
<li>MeshRenderer检视面板：CastShadows和ReceiveShadows，决定是否产生和接收阴影。其中CastShadows还有TwoSided选项，可以决定该模型是否双面都产生阴影。</li>
</ol>
</li>
<li>UnityShader中阴影的三个关键字
<ol>
<li>SHADOW_COORDS(x)：用于Struct v2f中定义阴影深度纹理。其中x要看我们的TEXCOORD使用了几个，比如我已经用了TEXCOORD0，TEXCOORD1，那么x就写2</li>
<li>TRANSFER_SHADOW(o)：用于顶点着色器中生成阴影深度纹理</li>
<li>SHADOW_ATTENUATION(i)：用于片元着色器中读取阴影颜色（用来和最终颜色相乘）</li>
</ol>
</li>
<li>默认Shader中已经实现了阴影深度纹理的采集，可以直接使用Fallback来避免重复代码</li>
<li>半透明物体的阴影
<ol>
<li>Unity默认半透明物体不产生阴影。</li>
<li>可以设置FallBack上的Shader，将其改为不透明物体使用的Shader，来让它强制产生阴影。</li>
</ol>
</li>
</ol>
<h3 id="第十章-高级纹理">第十章 高级纹理</h3>
<h4 id="立方体纹理">立方体纹理</h4>
<ol>
<li>使用原理：使用立方体纹理需要一个三维矢量。这个矢量以立方体中心为原点，发出的射线与立方体面相交的点即为采样点。</li>
<li>优点：实现简单快速，效果也比较好</li>
<li>缺点：当场景中光源，物体发生变化时，往往需要重新生成立方体纹理。用于反射时，立方体不能模拟多次反射的效果。（因此尽量不要对凹面的物体使用立方体纹理）</li>
<li>应用：
<ol>
<li>天空盒子：
<ol>
<li>Unity中可在LightSetting中设置当前场景的天空盒子</li>
<li>如果摄像机想使用自己的天空盒子，可以往摄像机上添加SkyBox组建，再将天空盒子拖到对应的位置。</li>
</ol>
</li>
<li>反射：基本算法就是根据视线方向和顶点法线，计算光线方向，然后使用入射方向在立方体纹理上采样，将采样后的颜色与原来光照的颜色进行混合/覆盖等操作。
<ol>
<li>立方纹理的采样方法：texCUBE(_TexName, i.xyz)</li>
</ol>
</li>
<li>折射：
<ol>
<li>物理依据：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mi>s</mi><mi>i</mi><mi>n</mi><msub><mi>b</mi><mn>1</mn></msub><mo>=</mo><msub><mi>a</mi><mn>2</mn></msub><mi>s</mi><mi>i</mi><mi>n</mi><msub><mi>b</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_1sinb_1 = a_2sinb_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：各自材质中的折射率</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">b_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：光与法线的夹角</li>
</ol>
</li>
<li>对透明物体来说，计算完折射方向直接采样是符合物理实际的，因为光线入射有折射，出射还以折射。但在实时计算中，计算二次折射比较复杂 ，所以通常只计算一次折射。</li>
<li>使用：<code>refract(-normalize(o.worldViewDir), normalize(o.worldNormal), _RefractRatio)</code>可以计算折射，其中<code>_refractRatio</code>为折射率。</li>
</ol>
</li>
<li>菲涅尔反射
<ol>
<li>物理现象：低头看水面，能看到水底；看水的远处，只能看到倒影</li>
<li>近似公式：
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>v</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo><mo>=</mo><msub><mi>F</mi><mn>0</mn></msub><mo>+</mo><mo>(</mo><mn>1</mn><mo>−</mo><msub><mi>F</mi><mn>0</mn></msub><mo>)</mo><mo>(</mo><mn>1</mn><mo>−</mo><mi>v</mi><mo separator="true">⋅</mo><mi>n</mi><msup><mo>)</mo><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">F(v, n) = F_0 + (1 - F_0)(1 - v·n)^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>
<ol>
<li>v：视角方向</li>
<li>n：表面法线</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">F_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：反射系数</li>
</ol>
</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>v</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mi>b</mi><mi>i</mi><mi>a</mi><mi>s</mi><mo>+</mo><mi>s</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>e</mi><mo separator="true">⋅</mo><mo>(</mo><mn>1</mn><mo>−</mo><mi>v</mi><mo separator="true">⋅</mo><mi>n</mi><msup><mo>)</mo><mrow><mi>p</mi><mi>o</mi><mi>w</mi><mi>e</mi><mi>r</mi></mrow></msup><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">F(v, n) = max(0, min(1,bias + scale·(1 - v · n)^{power}))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
</ol>
</li>
<li>公式使用方法：
<ol>
<li><code>lerp(diffuse, reflection, saturate(fresnel)</code></li>
<li>有些实现也会把fresnel与反射结果相乘，饭后叠加到漫反射上。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>立方体纹理的创建
<ol>
<li>使用特殊布局的纹理（比如立方体的展开图），然后将TextureShape设置成Cube，并在里面下拉出的选项进行相应设置。</li>
<li>使用脚本来生成CubeMap。调用<code>Camera.RenderToCubeMap()</code>（经过测试，Mac上2018版本的Unity，一勾CubeMap的Readable就崩溃了）</li>
<li>创建一个CubeMap（这个是旧版本方法），将6张图按顺序拖进去。</li>
</ol>
</li>
</ol>
<h4 id="渲染纹理中间缓冲">渲染纹理（中间缓冲）</h4>
<ol>
<li>Unity获取渲染纹理的方式
<ol>
<li>创建RenderTexture</li>
<li>使用GrabPass或者OnRenderImage获取当前屏幕图像</li>
</ol>
</li>
<li>应用：
<ol>
<li>镜子效果：使用一个新相机和RenderTexture实现。Shader里面UV的x进行一下左右翻转。</li>
<li>玻璃效果：
<ol>
<li>使用GrabPass，抓取所有不透明的图像</li>
<li>计算偏移，取折射值<pre><code class="language-shader">i.scrPos.xy = offset * i.scrPos.z + i.scrPos.xy;//离屏幕越远，偏移越大
fixed3 refrCol = tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;//透视除法得到真正的屏幕坐标。
</code></pre>
</li>
<li>计算反射方向，采样，得到反射颜色值</li>
<li>反射和折射进行混合。</li>
</ol>
</li>
</ol>
</li>
<li>RenderTexture和GrabPass的对比
<ol>
<li>GrabPass：实现简单，但抓取的图像和设备分辨率一样，高分辨率设备影响尤其严重。</li>
<li>RenderTexture：效率高。尽管需要额外的摄像机进行渲染，但我们可以设置渲染的层级，RenderTexture的质量等方式来减少消耗 。</li>
</ol>
</li>
</ol>
<h4 id="程序纹理">程序纹理</h4>
<p>实际上就是代码创建Texture并且向其中每个像素填充颜色。</p>
<h3 id="第11章-让画面动起来">第11章 让画面动起来</h3>
<h4 id="应用">应用</h4>
<ol>
<li>序列帧动画</li>
<li>滚动背景</li>
<li>顶点动画
<ol>
<li>模型空间内坐标进行偏移</li>
<li>需要额外设置标签&quot;DisableBatching&quot;，防止Unity批处理导致顶点动画不正确</li>
</ol>
</li>
<li>广告牌：让它看起来总是对着摄像机。（比如角色血条）
<ol>
<li>视角方向和表面法线方向总有一个是固定的</li>
<li>通过公式计算出变换矩阵
<ol>
<li>right = up X  normal</li>
<li>up' = normal X right<br>
<img src="https://singledigit9.github.io/post-images/1588677932028.jpeg" alt="" loading="lazy"></li>
</ol>
</li>
<li>转换模型空间中顶点坐标</li>
<li>需要额外设置标签&quot;DisableBatching&quot;，防止Unity批处理导致顶点动画不正确</li>
</ol>
</li>
</ol>
<h4 id="unity和批导致顶点动画不正确的原因">Unity和批导致顶点动画不正确的原因</h4>
<p>Unity和批后，模型各自的模型空间会丢失。</p>
<h4 id="一些注意事项">一些注意事项</h4>
<ol>
<li>尽量避免使用模型空间下的一些绝对位置做计算。</li>
<li>有顶点动画的阴影效果往往需要自己额外实现</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity Shader中常用的变换矩阵]]></title>
        <id>https://singledigit9.github.io/post/unity-shader-zhong-chang-yong-de-bian-huan-ju-zhen/</id>
        <link href="https://singledigit9.github.io/post/unity-shader-zhong-chang-yong-de-bian-huan-ju-zhen/">
        </link>
        <updated>2020-05-04T07:33:20.000Z</updated>
        <content type="html"><![CDATA[<p>速记：M模型空间；V：观察空间；P：剪裁空间；I：逆矩阵；T：转置矩阵</p>
<ol>
<li>UNITY_MATRIX_MVP 模型空间-&gt;剪裁空间
<ol>
<li>新版函数 UnityObjectToClipPos(float4 v)</li>
</ol>
</li>
<li>UNITY_MATRIX_MV 模型空间-&gt;观察空间</li>
<li>UNITY_MATRIX_V 世界空间-&gt;观察空间</li>
<li>UNITY_MATRIX_P 观察空间-&gt;剪裁空间</li>
<li>UNITY_MATRIX_VP 世界空间-&gt;剪裁空间</li>
<li>UNITY_MATRIX_T_MV 模型空间到观察空间的逆矩阵
<ol>
<li>如果UNITY_MATRIX_MV是正交矩阵的话，那么这个矩阵就是它的逆矩阵。可以将观察空间的坐标变换到模型空间。（只旋转和统一缩放）</li>
</ol>
</li>
<li>UNITY_MATRIX_IT_MV 模型空间到观察空间的逆转矩阵
<ol>
<li>用于法线从模型空间变换到观察空间</li>
<li>用于求UNITY_MATRIX_MV的逆矩阵（直接转置一下就可以了）</li>
</ol>
</li>
<li>_Object2World：模型空间到世界空间</li>
<li>_World2Object：世界空间到模型空间
<ol>
<li>新版矩阵 unity_WorldToObject<br>
<img src="https://singledigit9.github.io/post-images/1588321197724.jpeg" alt="" loading="lazy"></li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity Shader中的属性]]></title>
        <id>https://singledigit9.github.io/post/unity-shader-zhong-de-shu-xing-ding-yi-he-chu-shi-hua/</id>
        <link href="https://singledigit9.github.io/post/unity-shader-zhong-de-shu-xing-ding-yi-he-chu-shi-hua/">
        </link>
        <updated>2020-05-04T07:30:31.000Z</updated>
        <content type="html"><![CDATA[<h3 id="properties定义和初始化">Properties定义和初始化</h3>
<p><code>_Int(&quot;Int&quot;, Int) = 2</code><br>
<code>_Float(&quot;Float&quot;, Float) = 1.4</code><br>
<code>_Range(&quot;Range&quot;, Range(0, 1)) = 0.5</code><br>
<code>_Color(&quot;Color&quot;, Color) = (1, 0, 0, 0)</code><br>
<code>_Vector(&quot;Vector&quot;, Vector) = (1, 2, 3, 4)</code><br>
<code>_2D(&quot;2D&quot;, 2D) = &quot;white&quot;{}</code>（&quot;bump&quot;是unity内置的法线纹理）<br>
<code>_Cube(&quot;Cube&quot;, Cube) = &quot;&quot;{}</code><br>
<code>_3D(&quot;3D&quot;, 3D) = &quot;&quot;{}</code></p>
<h3 id="shaderlab中属性和cg中类型的对应关系">ShaderLab中属性和CG中类型的对应关系</h3>
<table>
<thead>
<tr>
<th>ShaderLab属性</th>
<th>CG变量类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Color, Vector</td>
<td>float4, half4, fixed4</td>
</tr>
<tr>
<td>Range, Float</td>
<td>float, half, fixed</td>
</tr>
<tr>
<td>2D</td>
<td>sampler2D</td>
</tr>
<tr>
<td>Cube</td>
<td>samplerCube</td>
</tr>
<tr>
<td>3D</td>
<td>sampler3D</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
</feed>