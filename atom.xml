<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://singledigit9.github.io</id>
    <title>资料库</title>
    <updated>2020-05-30T14:11:31.564Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://singledigit9.github.io"/>
    <link rel="self" href="https://singledigit9.github.io/atom.xml"/>
    <subtitle>One By One</subtitle>
    <logo>https://singledigit9.github.io/images/avatar.png</logo>
    <icon>https://singledigit9.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 资料库</rights>
    <entry>
        <title type="html"><![CDATA[《Unity Shader 入门精要》读书笔记（扩展篇）]]></title>
        <id>https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-kuo-zhan-pian/</id>
        <link href="https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-kuo-zhan-pian/">
        </link>
        <updated>2020-05-19T18:18:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第17章-unity表面着色器探秘">第17章 Unity表面着色器探秘</h1>
<h1 id="第18章-基于物理的渲染">第18章 基于物理的渲染</h1>
<h1 id="第19章-unity5更新了什么">第19章 Unity5更新了什么</h1>
<p>现在版本都2019了，这章好多东西应该都不适用了，更详细的应该查unity的更新文档了。但还是简单记录一下，万一遇到类似的问题能够快速反应过来。</p>
<ol>
<li>表面着色器报错。
<ol>
<li>通常是因为转换着色器时使用了一些额外的效果计算，比如法线，光照之类的。从而导致需求的寄存器数目超过限定的寄存器数目。</li>
<li>解决办法
<ol>
<li>可以将默认的Shader Model 2.0 改为3.0，即<code>#pragma target 3.0</code>。</li>
<li>可以手动设置该着色器不计算阴影纹理坐标（不接受阴影），不计算光照纹理和雾效 ，减少额外计算。即<code>#pragma surface surfaceFunction lightModeln oshadow nolightmap nofog</code></li>
</ol>
</li>
</ol>
</li>
<li>CPU不再处理非统一缩放，也就是说，CPU会把顶点信息和非统一缩放的矩阵直接传给Shader。因此在顶点片元着色器中变换顶点法线时，需要注意非统一缩放的影响，也要注意对变换后的法线进行手动归一化操作。</li>
<li>固定管线Shader被放弃。</li>
</ol>
<h1 id="第20章-还有更多内容么">第20章 还有更多内容么</h1>
<ol>
<li>OpenGL
<ol>
<li>红宝书：《OpenGL编程指南》</li>
<li>蓝宝书：《OpenGL超级宝典》</li>
</ol>
</li>
<li>GPU精粹系列</li>
<li>叶劲峰 ，计算机图形：入门/API类；Gems类</li>
<li>GPU Pro系列和ShaderX系列</li>
<li>物理渲染和光线追踪：《Physically based rendering : From theory to implementation》</li>
<li>学术会议（Ke-Sen Huang主页上有历年的论文）
<ol>
<li>SIGGRAPH</li>
<li>SIGGRAPH Asia</li>
<li>Eurographics</li>
<li>Symposium On Interactive 3D Graphics And Games</li>
</ol>
</li>
<li>Shadertoy网站</li>
<li>GLSL SandBox Gallery网站</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Unity Shader入门精要》读书笔记（高级篇）]]></title>
        <id>https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-gao-ji-pian/</id>
        <link href="https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-gao-ji-pian/">
        </link>
        <updated>2020-05-16T15:22:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第12章-屏幕后处理效果">第12章 屏幕后处理效果</h1>
<h2 id="脚本api">脚本API</h2>
<ol>
<li>相机脚本中使用的API</li>
</ol>
<pre><code class="language-c_sharp">Monobehavior.OnRenderImage(RenderTexture src, RenderTexture dest){}

Graphics.Blit(Texture src, RenderTexture dest);
Graphics.Blit(Texture src, RenderTexture dest,  Material mat, int pass =  -1);
Graphics.Blit(Texture src, Material mat, int pass = -1);
</code></pre>
<ol start="2">
<li>参数说明
<ol>
<li>src：源纹理</li>
<li>mat：使用的材质</li>
<li>dest：目标渲染纹理。为Null则直接将结果显示在屏幕上</li>
<li>pass：默认-1，表示会依次执行Shader中所有的Pass，否则只执行指定索引的Pass</li>
</ol>
</li>
<li><code>ImageEffectOpaque</code>：可以控制OnRenderImage执行的位置。比如当只想后处理不透明物体时，设置这个属性，使OnRenderIamge在不透明物体渲染完毕后立即调用。</li>
</ol>
<h2 id="应用">应用</h2>
<ul>
<li>屏幕后处理的标配 <code>ZTest Always Cull Off ZWrite Off</code></li>
</ul>
<h3 id="调节屏幕亮度饱和度和对比度">调节屏幕亮度，饱和度和对比度</h3>
<ol>
<li>亮度：颜色 * 亮度值</li>
<li>饱和度：</li>
</ol>
<pre><code class="language-shader">fixed4 color = tex2D(_MainTex, i.uv)
fixed temp = 0.2125 * color.r + 0.7154 * color.g + 0.0721  * color.b;
fixed tempColor = fixed(temp, temp, temp);
color = fixed4(lerp(tempColor, color.rgb, 饱和度值), color.a);
</code></pre>
<ol start="3">
<li>对比度：</li>
</ol>
<pre><code class="language-shader">color = (lerp(fixed3(0.5, 0.5, 0.5), color.rgb, 对比度值), color.a);
</code></pre>
<h3 id="边缘检测">边缘检测</h3>
<ol>
<li>常见的边缘检测算子<br>
<img src="https://singledigit9.github.io/post-images/1589705801787.jpeg" alt="" loading="lazy"></li>
<li>梯度计算
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><msqrt><mrow><msubsup><mi>G</mi><mi>x</mi><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>G</mi><mi>y</mi><mn>2</mn></msubsup></mrow></msqrt></mrow><annotation encoding="application/x-tex">G=\sqrt{G_x^2 + G_y^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.84em;vertical-align:-0.6765000000000001em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1635em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7401079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.1235em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.8800000000000001em;"><svg width='400em' height='1.8800000000000001em' viewBox='0 0 400000 1944' preserveAspectRatio='xMinYMin slice'><path d='M1001,80H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,
572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,
-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39
c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60
s208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,
-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5c4,-6.7,10,-10,18,-10z
M1001 80H400000v40H1013z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6765000000000001em;"><span></span></span></span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><mi mathvariant="normal">∣</mi><msub><mi>G</mi><mi>x</mi></msub><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><msub><mi>G</mi><mi>y</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">G = |G_x| + |G_y|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span></li>
</ol>
</li>
</ol>
<h3 id="高斯模糊">高斯模糊</h3>
<ol>
<li>高斯模糊卷积核<br>
<img src="https://singledigit9.github.io/post-images/1589706552526.jpeg" alt="" loading="lazy"></li>
<li><code>RenderTexture.GetTemporary</code>：获取一个缓存RenderTexture</li>
<li><code>RenderTexture.ReleaseTemporary</code>：释放缓存RenderTexture</li>
</ol>
<h3 id="bloom效果">Bloom效果</h3>
<ol>
<li>原理：根据阈值提取出较亮的区域，存在一个RenderTexture中，然后对它进行模糊，模拟光线扩散。最后将RenderTexture与原图向混合。</li>
<li>阈值提取</li>
</ol>
<pre><code class="language-shader">fixed luminance(fixed4 color) {
    return  0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b; 
}

fixed4 fragExtractBright(v2f i) : SV_Target {
    fixed4 c = tex2D(_MainTex, i.uv);
    fixed val = clamp(luminance(c) - _LuminanceThreshold, 0.0, 1.0);
    
    return c * val;
}
</code></pre>
<h3 id="运动模糊">运动模糊</h3>
<ol>
<li><code>RenderTexture.MarkRestoreExpected</code>：标记这个RenderTexture需要还原操作，避免Unity警告。</li>
<li>原理：
<ol>
<li>将多个图像进行叠加</li>
<li>使用速度缓存，根据速度来决定模糊采样的大小和方向</li>
</ol>
</li>
<li>书中使用的方法是在同一个RenderTexture上叠加图像来实现的。但速度过快时，会明显看到单帧的图像。</li>
</ol>
<h1 id="第13章-使用深度和法线纹理">第13章 使用深度和法线纹理</h1>
<ol>
<li>深度纹理本质上是一张渲染纹理，它存储的是深度值而不是颜色值。范围是 [0, 1]</li>
<li>深度值和NDC空间z坐标对应关系：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>=</mo><msub><mi>z</mi><mrow><mi>n</mi><mi>d</mi><mi>c</mi></mrow></msub><mo>∗</mo><mn>0.5</mn><mo>+</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">d =  z_{ndc} *  0.5 +  0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span></span></li>
<li>Unity得到深度纹理的流程
<ol>
<li>延迟渲染路径时，因为延迟渲染会把深度信息法线信息渲染都G-Buffer中，所以深度纹理和能够直接冲G-Buffer中获取，深度法线纹理一样简单合并一下就可以得到。</li>
<li>无法直接获取时，深度和法线纹理是通过单独的Pass来渲染获取的。Unity会使用<strong>着色器替换</strong>技术来选择那些渲染类型为<code>Opaque</code>的物体，判断它们的渲染队列是不是小于2500（包含BackGround，Geometry，AlphaTest），如果满足条件，则建起渲染到深度纹理中。因此，要想获得争取的深度纹理，就需要设置正确的<code>RenderType</code>。
<ol>
<li>Unity调用ShadowCaster的Pass来渲染深度纹理，因此，如果物体的Shader中不包含这个Pass，，那么这个物体就不会出现在深度纹理中。</li>
<li>Unity可以设置只渲染深度纹理还是渲染深度法线纹理。</li>
<li>因为前向渲染默认不创建深度缓存，所以Unity底层使用了额外的Pass来额外渲染。这个Pass在<code>/DefaultResources/Camera-DepthNormalTexture.shader</code>中。</li>
</ol>
</li>
</ol>
</li>
<li>深度纹理通常是24位或者16位。深度法线纹理通常是32位，其中法线存储在RG中，深度存储在BA中。</li>
<li>具体的获取
<ol>
<li>C#脚本中的API：<code>camera.depthTextureMode</code></li>
<li>Shader中声明的贴图：<code>_CameraDepthTexture</code>和<code>_CameraDepthNormalTexture</code>。</li>
<li>Shader中的采样
<ol>
<li>一般来说直接用tex2D就可以，但可能某些平台会不适用。</li>
<li>使用Unity内置的宏<code>float d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i,uv);</code></li>
<li>类似的还有<code>float d = SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(i.scrPos))</code>
<ol>
<li>第二个参数通常是由顶点着色器输出插值而得到的屏幕坐标。<code>i.scrPos = ComputeScreenPos(o.pos)</code></li>
<li>采样计算过程，使用前两个分量除以最后一个分量。</li>
</ol>
</li>
<li><code>DecodeDepthNormal(float4 depthNormalTexColor, out float depth, out float3 normal)</code>
<ol>
<li>需要注意返回的法线是视角空间下的法线方向。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>运动模糊
<ol>
<li>使用速度映射。通过深度纹理为每个像素计算其世界空间下的位置。并与前一帧的位置做差值，从而得到速度。好处是能够在一个屏幕后处理中完成整个效果，缺点就是性能消耗比较大。</li>
</ol>
</li>
<li>雾效
<ol>
<li>公式：<code>float3 afterFog = f * fogColor + (1 - f) * origColor</code>
<ol>
<li>雾效系数<code>f</code>的计算公式
<ol>
<li>线性：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>=</mo><mo>(</mo><msub><mi>d</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><mi mathvariant="normal">∣</mi><mi>z</mi><mi mathvariant="normal">∣</mi><mo>)</mo><mi mathvariant="normal">/</mi><mo>(</mo><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">f = (d_{max} - |z|)/({d_{max} - d_{min}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord">∣</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>指数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>d</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>z</mi><mi mathvariant="normal">∣</mi></mrow></msup></mrow><annotation encoding="application/x-tex">f = e^{-d*|z|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">d</span><span class="mbin mtight">∗</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mord mtight">∣</span></span></span></span></span></span></span></span></span></span></span></span></li>
<li>指数平方：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mo>(</mo><mi>d</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>z</mi><mi mathvariant="normal">∣</mi><msup><mo>)</mo><mn>2</mn></msup></mrow></msup></mrow><annotation encoding="application/x-tex">f = e^{-(d*|z|)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9869199999999998em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999998em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">d</span><span class="mbin mtight">∗</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mord mtight">∣</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="第14章-非真实感渲染">第14章 非真实感渲染</h1>
<h2 id="卡通风格渲染">卡通风格渲染</h2>
<h3 id="轮廓线">轮廓线</h3>
<ol>
<li>基于观察角度和法线：简单快速，但局限性很大，描边效果不好。</li>
<li>使用两个Pass，一个渲染背面，一个渲染正面。背面用纯色渲染稍微大一圈，组合到一起就是描边效果了。但这种方式仅仅适用于轮廓平滑的模型，不适用于立方体这类的模型。</li>
<li>基于图像处理的轮廓线渲染。使用算子进行边缘检测。适用范围广，效果较好。但一些深度法线变化小的轮廓可能无法检测出来。</li>
<li>基于轮廓边检测的轮廓线检测。原理是检测相邻的两个三角面的朝向是否不一致（是不是一个朝前一个朝后），如果不一致则两个三角面之间有一条轮廓线。但这种方式也有缺点，一个是实现复杂，另一个是动画在帧与帧之间不连贯。
<ol>
<li>公式：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>n</mi><mn>0</mn></msub><mo separator="true">⋅</mo><mi>v</mi><mo>&gt;</mo><mn>0</mn><mo>)</mo><mo>!</mo><mo>=</mo><mo>(</mo><msub><mi>n</mi><mn>1</mn></msub><mo separator="true">⋅</mo><mi>v</mi><mo>&gt;</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(n_0 · v &gt; 0) != (n_1 · v &gt; 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></li>
</ol>
</li>
</ol>
<h3 id="高光">高光</h3>
<p>卡通的高光相比于一般的高光来说，颜色过度更贱&quot;生硬&quot;。因此我们将普通的高光公式所求的的值，与一个阈值进行比较，小于该阈值直接为0，大于该阈值直接为1.</p>
<h2 id="素描风格渲染">素描风格渲染</h2>
<ol>
<li>使用了色调艺术映射的技术。</li>
<li>根据观察方向和法线的点积值，if判断，来确定使用那个贴图的素材。从而叠加渲染。</li>
</ol>
<h1 id="第15章-使用噪声">第15章 使用噪声</h1>
<ol>
<li>消融效果：在噪声图上采样，得到噪声值。然后将当前颜色值与噪声值进行比较，大于或者小于的直接将该片元discard。剩余的片元再次处理一下边缘颜色就可以了。</li>
<li>水波效果：基于时间，在法线噪声图上采样。用采样得到的法线值，计算颜色偏移等。</li>
<li>烟雾飘动的效果。</li>
</ol>
<h1 id="第16章-unity中的渲染优化技术">第16章 Unity中的渲染优化技术</h1>
<p>首要规则：过度优化和不优化一样严重。</p>
<p>此外有一篇关于Unity优化的导图文章特别好，写的很全。基本上按照那个导图一个流程走下来，性能应该没什么大问题。但因为那个导图是收费的，这里不好直接贴上来。放一个链接，有兴趣可以去查看。</p>
<p><a href="https://mm.edrawsoft.cn/store">在线思维导图(在搜索里搜Unity就能找到了)</a></p>
<h2 id="移动平台的特点">移动平台的特点</h2>
<ol>
<li>移动设备一般使用基于Tile的延迟渲染架构，即将图像装入一个个tile中。然后再由硬件选择将tile中的哪个图像渲染到屏幕上。</li>
<li>基于上面描述的渲染架构的特点，overDraw（就是一个像素被多次绘制）很有可能是性能瓶颈。</li>
</ol>
<h2 id="影响性能的因素">影响性能的因素</h2>
<ol>
<li>CPU
<ol>
<li>draw Call</li>
<li>逻辑</li>
<li>物理</li>
</ol>
</li>
<li>GPU
<ol>
<li>顶点
<ol>
<li>顶点过多</li>
<li>顶点计算过多</li>
</ol>
</li>
<li>片元
<ol>
<li>过多的片元</li>
<li>逐片元计算过多</li>
</ol>
</li>
</ol>
</li>
<li>带宽
<ol>
<li>尺寸过大的未压缩的纹理</li>
<li>分辨率过高的帧缓存</li>
</ol>
</li>
</ol>
<h2 id="unity中的分析工具">Unity中的分析工具</h2>
<ol>
<li>
<p>渲染统计信息。Game窗口的Stats<br>
<img src="https://singledigit9.github.io/post-images/1590816549696.jpeg" alt="" loading="lazy"><br>
<img src="https://singledigit9.github.io/post-images/1590816560024.jpeg" alt="" loading="lazy"></p>
</li>
<li>
<p>Profiler<br>
可以动态查看当前帧的消耗情况。但需要注意的是，编辑器下的调试有一定的参考价值，但和真机上还是有差别。</p>
</li>
<li>
<p>帧调试器<br>
可以看每一帧都渲染了什么东西，有什么东西是应该一起渲染的但是没有一起渲染（这个对FairyGUI尤其有用。优化时FairyGUI往往调整一下层级就会减少一些DrawCall）</p>
</li>
</ol>
<h2 id="动态批处理">动态批处理</h2>
<ol>
<li>顶点数小于900。如果Shader中使用了顶点位置，法线，纹理坐标这3个顶点属性，那么就要小于300</li>
<li>同一个缩放尺度下。（书上说Unity5之后已经对这个进行了优化，但我在Unity2018下用Cube进行试验，不同缩放尺度的Cube一样会增加DrawCall，想动态批处理的话，这个最好还是严格遵守）</li>
<li>需要动态批处理的物体应该指向光照纹理的同一个位置。（<strong>光照纹理这部分接触较少，需要深入学习</strong>）</li>
<li>多Pass的Shader会中断批处理操作。</li>
</ol>
<h2 id="静态批处理">静态批处理</h2>
<p>运行开始阶段，将需要静态批处理的网格合并到一个大网格中。<br>
静态批处理相比于动态批处理更加高效，但仍然有一些缺点。</p>
<ol>
<li>静态批处理的物体不能够移动</li>
<li>往往会占用更多的内存。因为一些物体如果共享了相同的网格，合并前每一个物体都会有一个该网格的复制。最终导致一个网格的多个复制会发给GPU，从而导致性能瓶颈。
<ol>
<li>例子：1000个相同模型的树，如果使用了静态批处理，则会吧这个模型的1000的复制合并到一个大网格里进行处理。也就是说，一个树的模型，我们多消耗了999个单位的内存空间。</li>
</ol>
</li>
</ol>
<h2 id="共享材质">共享材质</h2>
<p>关键字：shareMaterial</p>
<ol>
<li>使用Renderer.Material时，会创建一份原始材质球的复制，造成额外消耗。</li>
<li>使用Renderer.ShareMaterial时，会修改原始的材质球，从而使使用这个材质球的模型都收到影响。</li>
</ol>
<h2 id="减少顶点">减少顶点</h2>
<ol>
<li>模型制作，去除不必要的顶点和边</li>
<li>LOD</li>
<li>遮挡剔除技术（<strong>这个需要重点学习一下，之前没有用过。</strong>）</li>
</ol>
<h2 id="减少片元">减少片元</h2>
<ol>
<li>减少overDraw
<ol>
<li>最最主要的，尽可能不要用半透明的渲染队列。半透明物体会破坏渲染队列。</li>
<li>对于UI，如果无法避免半透明，可以将UI的相机和其他的场景相机分开，不要一起渲染。</li>
<li>透明度测试也会影响游戏性能。discard和clip操作可能会导致一些硬件的优化策略失败。</li>
</ol>
</li>
<li>减少实时光照和阴影
<ol>
<li>灯光贴图</li>
<li>移动平台上，物体的逐像素光照光源数目应该小于1（不包括平行光）。如果为了效果需要多个光源，请使用逐顶点光照。</li>
<li>将光照计算存储到纹理中。根据光源方向，视角方向，法线方向等直接从纹理采样得到信息。但这种方法需要编写对应的美术编辑器，</li>
</ol>
</li>
</ol>
<h2 id="较少带宽">较少带宽</h2>
<ol>
<li>减少纹理大小。纹理大小应该是2的整数次幂。纹理压缩格式在不影响效果的情况下，应该压缩到最小。</li>
<li>有些设备空有高分辨率的屏幕而没有配套的其他硬件，从而导致游戏在那个设备上运行时效果不好。可以使用Screen.SetResolution来设置分辨率。（<strong>这块需要进一步查阅资料学习</strong>）</li>
</ol>
<h2 id="减少计算复杂度">减少计算复杂度</h2>
<ol>
<li>Shader中的LOD
<ol>
<li>只有Shader中的LOD小于指定值时，这个Shader才会被使用。</li>
<li>内置的Diffuse的LOD是200，BumpedSpecular是400。</li>
</ol>
</li>
<li>Shader代码
<ol>
<li>计算数目排序：物体数量 &lt; 顶点数量 &lt; 片元数量</li>
<li>尽可能把计算上移，减少计算。</li>
<li>尽可能使用低精度浮点数进行计算</li>
<li>避免不同精度数来回切换</li>
<li>避免频繁的color.rgrg操作</li>
<li>尽可能不要用屏幕后处理</li>
<li>如果需要使用屏幕后处理，尽可能把多个特效封到一个Shader里</li>
<li>尽可能不要用分支和循环，sin, tan, pow，等费时操作，以及discard操作。</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AssetBundle官方文档学习笔记]]></title>
        <id>https://singledigit9.github.io/post/assetbundle-guan-fang-wen-dang-xue-xi-bi-ji/</id>
        <link href="https://singledigit9.github.io/post/assetbundle-guan-fang-wen-dang-xue-xi-bi-ji/">
        </link>
        <updated>2020-05-13T14:14:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="文档版本地址">文档版本&amp;地址</h1>
<p>2019.3 <a href="https://docs.unity3d.com/Manual/AssetBundlesIntro.html">https://docs.unity3d.com/Manual/AssetBundlesIntro.html</a></p>
<h1 id="官方工具">官方工具</h1>
<p><a href="https://docs.unity3d.com/Packages/com.unity.addressables@1.8/manual/index.html">Unity Addressable Asset system</a><br>
<a href="https://github.com/Unity-Technologies/AssetBundles-Browser">Unity Asset Bundle Browser tool</a><br>
<a href="https://docs.unity3d.com/Manual/AssetBundles-Browser.html">Unity Asset Bundle Browser tool文档</a></p>
<h1 id="基础介绍">基础介绍</h1>
<h2 id="assetbundle的特性">AssetBundle的特性</h2>
<ul>
<li>AssetBundle能够互相依赖。例如，一个AssetBundle中的材质球能够引用另一个AssetBundle上的贴图。</li>
<li>AssetBundle能够使用Unity内置的算法进行压缩，以提高传输效率。</li>
</ul>
<h2 id="assetbundle能够做什么">AssetBundle能够做什么</h2>
<ul>
<li>DLC的更新</li>
<li>减少初始安装包大小</li>
<li>减小运行时内存压力</li>
<li>针对用户的终端（手机）加载优化资源</li>
</ul>
<h2 id="assetbundle文件和assetbundle对象">AssetBundle文件和AssetBundle对象</h2>
<ul>
<li>AssetBundle文件中包含的是打入其中的各种资源。</li>
<li>AssetBundle对象中有一个Key值为路径，Value值为对应资源的字典。</li>
</ul>
<h1 id="工作流程">工作流程</h1>
<h2 id="资源的设置">资源的设置</h2>
<ol>
<li>选中要打包的资源，在检视面板的最下面可以看到AssetBundle配置选项。</li>
<li>第一个配置：要将这个资源打进哪一个AssetBundle<strong>待测试</strong></li>
<li>第二个配置：这个资源的变体<strong>待测试</strong></li>
</ol>
<h2 id="资源的打包">资源的打包</h2>
<p>官网提供了示例代码<strong>待测试</strong></p>
<pre><code>using UnityEditor;
using System.IO;

public class CreateAssetBundles
{
    [MenuItem(&quot;Assets/Build AssetBundles&quot;)]
    static void BuildAllAssetBundles()
    {
        string assetBundleDirectory = &quot;Assets/AssetBundles&quot;;
        if(!Directory.Exists(assetBundleDirectory))
        {
            Directory.CreateDirectory(assetBundleDirectory);
        }
        BuildPipeline.BuildAssetBundles(assetBundleDirectory, 
                                        BuildAssetBundleOptions.None, 
                                        BuildTarget.StandaloneWindows);
    }
}
</code></pre>
<h2 id="加载assetbundle和assetbundle里面的资源">加载AssetBundle和AssetBundle里面的资源</h2>
<h3 id="加载本地文件">加载本地文件</h3>
<p>官网示例代码<strong>待测试</strong></p>
<pre><code>public class LoadFromFileExample : MonoBehaviour {
    function Start() {
        var myLoadedAssetBundle 
            = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, &quot;myassetBundle&quot;));
        if (myLoadedAssetBundle == null) {
            Debug.Log(&quot;Failed to load AssetBundle!&quot;);
            return;
        }
        var prefab = myLoadedAssetBundle.LoadAsset&lt;GameObject&gt;(&quot;MyObject&quot;);
        Instantiate(prefab);
    }
}
</code></pre>
<h3 id="加载网络文件">加载网络文件</h3>
<pre><code>IEnumerator InstantiateObject()
{
    string url = &quot;file:///&quot; + Application.dataPath + &quot;/AssetBundles/&quot; + assetBundleName;        
    UnityEngine.Networking.UnityWebRequest request 
        = UnityEngine.Networking.UnityWebRequest.GetAssetBundle(url, 0);
    yield return request.Send();
    AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);
    GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;);
    GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;(&quot;Sprite&quot;);
    Instantiate(cube);
    Instantiate(sprite);
}
</code></pre>
<h1 id="打包策略">打包策略</h1>
<ul>
<li>开发人员应该明确知道在什么时候什么位置使用什么资源。明确了这个问题后才能够决定使用什么打包策略。</li>
</ul>
<h2 id="依据实体打包">依据实体打包</h2>
<ul>
<li>举例：
<ul>
<li>将一个UIPrefab和它所用到的贴图打包在一起</li>
<li>将一个模型和这个模型的材质球，贴图，动画文件打包在一起</li>
<li>将一个场景和这个场景所用到的资源打包在一起</li>
</ul>
</li>
<li>特点
<ul>
<li>每个实体的AssetBundle是分开的，更新单独的实体时不用更新其他没有改变的资源</li>
</ul>
</li>
</ul>
<h2 id="依据资源类型打包">依据资源类型打包</h2>
<ul>
<li>特点
<ul>
<li>不同平台下压缩格式相同的资源AssetBundle可以在不同平台下重用</li>
</ul>
</li>
</ul>
<h2 id="选择正确的打包策略">选择正确的打包策略</h2>
<ul>
<li>AssetBundle是有依赖关系的。如果你的AssetBundle打包策略不好，可能会出现想加载一个GameObject而需要加载多个AssetBundle的情况。</li>
<li>上面两种策略当然也可以混合使用。这需要根据具体的项目需求来进行选择。</li>
</ul>
<h3 id="关键点">关键点</h3>
<ul>
<li>将经常变化的资源和很少变化的资源分开打包。</li>
<li>理清资源依赖关系，避免复杂的相互依赖。比如将通用的依赖资源移到Common中。</li>
<li>不可能同时加载使用的资源不要打进一个AssetBundle里</li>
<li>如果一个AssetBundle中只有一部分资源被频繁的加载，那么需要把这个AssetBundle进行拆分</li>
<li>将同时频繁加载的小（资源数少于5-10）的AssetBundle合并到一起。</li>
<li>不同版本的同一物体，可以考虑使用变体 <strong>变体具体是什么待测试</strong></li>
</ul>
<h1 id="打包assetbundle">打包AssetBundle</h1>
<h2 id="buildassetbundleoptions">BuildAssetBundleOptions</h2>
<ul>
<li>关于打AssetBundle的各种设置  <strong>待测试</strong></li>
</ul>
<table>
<thead>
<tr>
<th>API</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>没有特殊设置。使用LZMA进行压缩</td>
</tr>
<tr>
<td>UncompressedAssetBundle</td>
<td>不对AssetBundle进行压缩</td>
</tr>
<tr>
<td>DisableWriteTypeTree</td>
<td>AssetBundle中不包含类型信息</td>
</tr>
<tr>
<td>DeterministicAssetBundle</td>
<td>确保相同的资源打进AssetBundle里面后，哈希值不会变化</td>
</tr>
<tr>
<td>ForceRebuildAssetBundle</td>
<td>强制重新打AssetBundle</td>
</tr>
<tr>
<td>IgnoreTypeTreeChanges</td>
<td>增量打包时忽略类型树变化</td>
</tr>
<tr>
<td>AppendHashToAssetBundleName</td>
<td>将Hash值添加到AssetBundle名字之后，能够从名字直接看出AssetBundle是否有变化</td>
</tr>
<tr>
<td>ChunkBasedCompression</td>
<td>使用LZ4格式压缩</td>
</tr>
<tr>
<td>StrictMode</td>
<td>打包过程中报错则中断打包</td>
</tr>
<tr>
<td>DryRunBuild</td>
<td>Do a dry run build.</td>
</tr>
<tr>
<td>DisableLoadAssetByFileName</td>
<td>不允许使用文件名字加载资源</td>
</tr>
<tr>
<td>DisableLoadAssetByFileNameWithExtension</td>
<td>不允许使用带后缀的文件名字加载资源</td>
</tr>
<tr>
<td>AssetBundleStripUnityVersion</td>
<td>构建时删除Unity版本号</td>
</tr>
</tbody>
</table>
<h2 id="关于压缩格式">关于压缩格式</h2>
<ul>
<li>默认情况下，使用LZMA格式创建，使用LZ4格式缓存</li>
</ul>
<h3 id="压缩格式类型">压缩格式类型</h3>
<ul>
<li>LZMA：
<ul>
<li>打出的AssetBundle最小，但加载时间也会更长（加载资源之前需要先将资源所在的AssetBundle整个进行解压）。</li>
<li>资源解压后，会使用LZ4格式重新压缩。</li>
<li>推荐在初始资源下载时使用这个格式。</li>
<li>通过<code>UnityWebRequestAssetBundle</code>加载的LZMA格式的AssetBundle会自动解压并重新压缩为LZ4，缓存到本地。如果是使用其他方式下载的Assetbundle,则可以使用<code>AssetBundle.RecompressAssetBundleAsync</code>对其进行重新压缩</li>
</ul>
</li>
<li>LZ4：
<ul>
<li>加载资源前不必对整个AssetBundle进行解压</li>
<li>允许以块的形式加载资源。解压单个块，即使当前AssetBund中其他的块没有解压，也能使用当前块中的资源</li>
<li>这种压缩模式下<code>AssetBundle.LoadFromFile</code>只在内存里加载Bundle的资源目录，而不是Bundle本身</li>
</ul>
</li>
<li>完全不压缩：
<ul>
<li>文件大，加载快</li>
</ul>
</li>
</ul>
<h2 id="打包生成的文件">打包生成的文件</h2>
<ul>
<li>
<p>AssetBundle文件</p>
<ul>
<li>场景Bundle和其他一般资源Bundle里面的结构略有不同。场景的Bundle有一些特殊优化。<br>
<img src="https://singledigit9.github.io/post-images/1589379363606.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>
<p>Manifest文件</p>
<ul>
<li>包含了当前AssetBundle的资源信息以及资源的依赖信息</li>
</ul>
</li>
</ul>
<h1 id="assetbundle依赖">AssetBundle依赖</h1>
<ul>
<li>一个Bundle中的资源引用另一个Bundle中的资源会产生依赖；一个Bundle中的资源引用一个不在Bundle中的资源不会产生依赖。</li>
<li>如果Bundle中资源A引用不在Bundle中的资源B，则资源B会被复制并打进A的Bundle中。</li>
<li>如果多个Bundle中的资源引用不在Bundle中的资源B，则资源B会被复制并打进每一个Bundle中。</li>
<li>如果要加载的Bundle A中的资源依赖Bundle B，那么加载这个资源前要先将Bundle B加载好。</li>
</ul>
<h2 id="跨assetbundle的重复信息">跨AssetBundle的重复信息</h2>
<ul>
<li>如果一个Bundle中有一个预制，都引用了不在Bundle中的材质球和贴图
<ul>
<li>影响最终打出来的Bundle大小增加</li>
<li>运行时内存占用增加</li>
<li>影响Unity自动批处理。Unity把不同Bundle中的材质球都看作是唯一的。</li>
</ul>
</li>
</ul>
<h2 id="编辑器下依赖关系的查询">编辑器下依赖关系的查询</h2>
<ul>
<li><code>AssetDatabase</code>：查询依赖关系</li>
<li><code>AssetImporter</code>：查询资源分配到了哪个AssetBundle</li>
</ul>
<h2 id="几种依赖关系的处理方法">几种依赖关系的处理方法</h2>
<ul>
<li>共同的依赖资源集中到一个Bundle里面（不适用于复杂交叉依赖的情况）</li>
<li>确保同一时间，不会有任何一个Bundle有多重被依赖。（适用于基于Level的游戏，但这样做仍然会增加AssetBundle的文件大小）</li>
<li>确保所有依赖的资源都在自己的AssetBundle里面。但这样做机制比较复杂。</li>
</ul>
<h1 id="assetbundle的使用">AssetBundle的使用</h1>
<h2 id="加载assetbundle">加载AssetBundle</h2>
<ul>
<li><code>AssetBundle.LoadFromMemoryAsync</code>
<ul>
<li>从内存异步加载AssetBundle</li>
<li>参数为Bundle文件的字节流</li>
<li>使用示例：</li>
</ul>
</li>
</ul>
<pre><code>using UnityEngine;
using System.Collections;
using System.IO;

public class Example : MonoBehaviour
{
    IEnumerator LoadFromMemoryAsync(string path)
    {
        AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path));
        yield return createRequest;
        AssetBundle bundle = createRequest.assetBundle;
        var prefab = bundle.LoadAsset&lt;GameObject&gt;(&quot;MyObject&quot;);
        Instantiate(prefab);
    }
}
</code></pre>
<ul>
<li><code>AssetBundle.LoadFromFile</code>
<ul>
<li>未压缩和LZ4格式压缩的AssetBundle，会直接从硬盘中加载。加载LZMA格式的AssetBundle时，会先解压，然后再加载。</li>
<li>加载本地的未压缩资源效率很高。</li>
<li>Unity5.3以及以前版本，Android平台使用这个API加载StreamingAssets文件夹中的AssetBundle会失败。因为StreamingAssets文件夹中的内容会在一个压缩的.jar文件中。</li>
<li>Unity5.4以及更新的版本能够正常的使用这个API.</li>
<li>使用示例：</li>
</ul>
</li>
</ul>
<pre><code>public class LoadFromFileExample : MonoBehaviour {
    function Start() {
        var myLoadedAssetBundle 
            = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, &quot;myassetBundle&quot;));
        
        if (myLoadedAssetBundle == null) {
            Debug.Log(&quot;Failed to load AssetBundle!&quot;);
            return;
        }
        var prefab = myLoadedAssetBundle.LoadAsset.&lt;GameObject&gt;(&quot;MyObject&quot;);
        Instantiate(prefab);
    }
}
</code></pre>
<ul>
<li><code>UnityWebRequest</code>
<ul>
<li>相当于原来的<code>WWW</code>类的升级版。</li>
<li>能够方便的处理下载以及HTTP的Get/POST请求。</li>
<li>使用示例：</li>
</ul>
</li>
</ul>
<pre><code>IEnumerator InstantiateObject()
{
    string uri = &quot;file:///&quot; + Application.dataPath + &quot;/AssetBundles/&quot; + assetBundleName; 
    UnityEngine.Networking.UnityWebRequest request 
        = UnityEngine.Networking.UnityWebRequest.GetAssetBundle(uri, 0);
    yield return request.Send();
    AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);
    GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;);
    GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;(&quot;Sprite&quot;);
    Instantiate(cube);
    Instantiate(sprite);
}
</code></pre>
<ul>
<li><code>WWW.LoadFromCacheOrDownload</code>[已淘汰，直接跳过]</li>
</ul>
<h2 id="加载assetbundle中的资源">加载AssetBundle中的资源</h2>
<ul>
<li><code>T objectFromBundle = bundleObject.LoadAsset&lt;T&gt;(assetName);</code></li>
<li><code>Unity.Object[] objectArray = loadedAssetBundle.LoadAllAssets();</code></li>
<li></li>
</ul>
<pre><code>AssetBundleRequest request = loadedAssetBundleObject.LoadAssetAsync&lt;GameObject&gt;(assetName);
yield return request;
var loadedAsset = request.asset;
</code></pre>
<ul>
<li></li>
</ul>
<pre><code>AssetBundleRequest request = loadedAssetBundle.LoadAllAssetsAsync();
yield return request;
var loadedAssets = request.allAssets;
</code></pre>
<h2 id="加载manifest文件">加载Manifest文件</h2>
<ul>
<li>加载Manifest文件是为了解决依赖问题</li>
<li>加载Manifest文件的示例代码</li>
</ul>
<pre><code>AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);
AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;);
</code></pre>
<ul>
<li>查询并加载依赖的示例代码</li>
</ul>
<pre><code>AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);
AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;);
string[] dependencies = manifest.GetAllDependencies(&quot;assetBundle&quot;); //Pass the name of the bundle you want the dependencies for.
foreach(string dependency in dependencies)
{
    AssetBundle.LoadFromFile(Path.Combine(assetBundlePath, dependency));
}
</code></pre>
<h1 id="管理加载的assetbundle">管理加载的AssetBundle</h1>
<ul>
<li>不正确的卸载AssetBundle可能导致复制内存中的object或者其他问题，比如贴图丢失。</li>
</ul>
<h2 id="assetbundleunloadbool"><code>AssetBundle.Unload(bool)</code></h2>
<ul>
<li>卸载AssetBundle的头部信息</li>
</ul>
<h3 id="参数详细说明">参数详细说明</h3>
<ul>
<li>参数为true时 也卸载AssetBundle所有的实例化对象，这个实例化对象不包含对象的复制（复制的资源不是AssetBundle里面的资源）。</li>
<li>多数情况下，会使用true来保证内存中没有重复的对象</li>
<li>如果参数必须为false的话，内存中无法访问的资源只能通过以下方式卸载
<ul>
<li>手动调用<code>Resources.UnloadUnusedAssets</code></li>
<li>非添加方式加载场景，会自动调用<code>Resources.UnloadUnusedAssets</code></li>
</ul>
</li>
</ul>
<h4 id="详细例子">详细例子</h4>
<ul>
<li>从AssetBundle中加载的一个GameObject资源，true卸载时，会把这个GameObject资源卸载掉，而不会把Instantiate的GameObject也卸载掉。</li>
<li>现在从AssetBundle中加载一个材质球在活动场景中使用
<ul>
<li>使用Unload(true)卸载时，材质球在场景中的所有实例一样会被卸载和销毁。<strong>这里有个疑问待测试：Instantiate的材质球会不会也被销毁</strong></li>
<li>使用Unload(false)卸载时，会打断当前材质球和AssetBundle的链接。如果AssetBundle重新加载，它并不会链接到已经存在的材质球。此时加载该材质球时，会复制一个新的。</li>
</ul>
</li>
</ul>
<p><img src="https://singledigit9.github.io/post-images/1589379410371.png" alt="" loading="lazy"><br>
<img src="https://singledigit9.github.io/post-images/1589379417761.png" alt="" loading="lazy"><br>
<img src="https://singledigit9.github.io/post-images/1589379424865.png" alt="" loading="lazy"></p>
<h2 id="保证资源不重复的方法">保证资源不重复的方法</h2>
<ul>
<li>在恰当的时机卸载暂时加载的AssetBundle，比如Loading时</li>
<li>记录资源加载的引用计数，避免重复加载资源和异常卸载资源</li>
</ul>
<h1 id="assetbundle缓存">AssetBundle缓存</h1>
<ul>
<li>Unity维护两个缓存，分别是内存缓存和硬盘缓存。</li>
<li>将AssetBundle中加载到内存中，会消耗大量的内存空间。除非有特别频繁快速访问AssetBundle中内容的需求，否则请使用磁盘缓存。</li>
<li>如果你向<code>UnityWebRequest</code>提供了一个版本参数（版本号挥着Hash），Unity会将AssetBundle数据存储到本地硬盘。如果不提供参数，Unity将会使用内存缓存。</li>
<li><code>Caching.compressionEnabled</code>设置为true时，存储到本地的AssetBundle文件会以LZ4的格式进行压缩；设置为false时，则存储到本地的文件不会压缩。</li>
<li>使用LZMA格式初始加载会耗费比较长的时间。因为它需要先解压，然后以指定格式存储到硬盘缓存。之后加载会直接使用缓存来加载。</li>
<li>推荐使用<code>UnityWebRequest</code>，因为<code>AssetBundle.LoadFromFile</code>和<code>AssetBundle.LoadFromFileAsync</code>加载LZMA后会使用内存中的缓存。如果不能使用<code>UnityWebRequest</code>，可以使用<code>AssetBundle.RecompressAssetBundleAsync</code>手动将AssetBundle数据写到硬盘缓存上。</li>
<li>内部测试表明，使用磁盘缓存和内存缓存存在着一个数量级的差异。需要根据项目的需求自己权衡。</li>
</ul>
<h2 id="缓存类型">缓存类型</h2>
<ol>
<li>内存缓存：AssetBundle为不压缩格式</li>
<li>硬盘缓存：在可写空间以指定格式压缩保存AssetBundle文件</li>
</ol>
<h1 id="assetbundle补丁">AssetBundle补丁</h1>
<ul>
<li>下载一个新的AssetBundle来替换现有的AssetBundle</li>
<li>使用<code>UnityWebRequest</code>API时，会根据传入的版本参数自动触发下载新的AssetBundle</li>
<li>Unity使用固定方式生成AssetBundle文件，也就是说，资源不变，生成的AssetBundle也是不变的。正因为这样，可以自定义下载器来区分补丁差异。</li>
<li>Unity内部并没有实现差分补丁的功能，如果有差分补丁的需求的话，需要手动实现。（差分补丁：新AssetBundle和旧AssetBundle进行比较生成补丁。客户端下载补丁并经过处理生成新AssetBundle）</li>
</ul>
<h2 id="如何确定要替换的assetbundle">如何确定要替换的AssetBundle</h2>
<ul>
<li>从服务器获取要下载的资源列表和版本信息。和本地的资源列表版本信息做对比。如果本地资源缺失或者版本号不对，则需要下载替换这个AssetBundle。</li>
<li>也可以自定义系统来检测AssetBundle变化，比如MD5，JSON等。</li>
</ul>
<h1 id="常见问题">常见问题</h1>
<h2 id="自动生成的图集">自动生成的图集</h2>
<ul>
<li>如果一个图集的所有sprite都打进同一个Bundle，则自动生成的图集将会打进这个Bundle。</li>
<li>如果sprite被打进多个Bundle，那么图集会复制多分分别打进对应的Bundle。</li>
<li>如果sprite没有被打进Bundle，那么图集也不会被打进Bundle</li>
<li>Unity5.2.2p3以及以前的版本对图集打Bundle的支持有问题。</li>
</ul>
<h2 id="android-texture">Android Texture</h2>
<ul>
<li>Android设备碎片化问题严重，需要将贴图压缩成对应的格式。</li>
<li>ETC1没有透明通道，但基本上所有设备都支持</li>
<li>ETC2，旧设备可能不支持</li>
<li>可以使用变体，将不同变体的贴图分别打在一个AssetBundle里面，根据情况进行加载。（需要贴图设置正确）</li>
<li><code>SystemInfo.SupportedTextureFormat</code>可以使用这个API来检测设备支持什么格式的贴图</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity Shader的内置时间变量]]></title>
        <id>https://singledigit9.github.io/post/unity-shader-de-nei-zhi-shi-jian-bian-liang/</id>
        <link href="https://singledigit9.github.io/post/unity-shader-de-nei-zhi-shi-jian-bian-liang/">
        </link>
        <updated>2020-05-05T11:06:44.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://singledigit9.github.io/post-images/1588676867160.jpeg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Unity Shader 入门精要》读书笔记（中级篇共三章）]]></title>
        <id>https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-zhong-ji-pian/</id>
        <link href="https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-zhong-ji-pian/">
        </link>
        <updated>2020-05-04T07:49:40.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="写在前面">写在前面</h3>
<p>有不少地方不好理解，需要仔细研究</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="写在前面">写在前面</h3>
<p>有不少地方不好理解，需要仔细研究</p>
<!-- more -->
<h3 id="第九章-更复杂的光照">第九章 更复杂的光照</h3>
<p>Shader中的渲染路径设置写在另一篇文章里面，方便查阅。</p>
<h4 id="unity中的渲染路径">Unity中的渲染路径</h4>
<ol>
<li>
<p>Unity中渲染路径的设置</p>
<ol>
<li>全局的渲染路径设置：Other Setting--&gt;Rendering Path</li>
<li>特殊的渲染路径设置：Camera的检视面板上的Rendering Path</li>
<li>需要注意的是，如果当前显卡不支持当前的渲染路径，Unity则会自动使用更低一级的渲染路径。比如，一个GPU不支持延迟路径，则Unity会自动使用前向路径。</li>
</ol>
</li>
<li>
<p>渲染路径的类型</p>
<ol>
<li>
<p>前向渲染：传统的渲染方式，也是最常用的渲染方式。当场景中有大量的实时光源时，性能会极速下降。</p>
<ol>
<li>基本任务：渲染每个渲染图元，并且计算颜色缓冲区和深度缓冲区的信息。</li>
<li>大致步骤：每次前向渲染，对于每一个片元，都会进行深度测试。如果没有通过测试，则直接将该片元丢弃；如果通过深度测试，则片元进行正常的一系列计算最终更新颜色缓冲区。</li>
<li>每一个逐像素光源，都会执行上面的步骤。如果一个物体在多个逐像素光源下，那么这个物体就要执行多个 Pass，每个Pass的光照结果进行混合，来得到最终的颜色值。</li>
<li>一般而言引擎会限制逐像素光照的数目。</li>
<li>Unity中前向渲染光照的3种处理方式
<ol>
<li>逐顶点</li>
<li>逐像素</li>
<li>球协函数（SH）：拓展文章<a href="https://huailiang.github.io/blog/2019/harmonics/"><em>球谐光照</em></a></li>
</ol>
</li>
<li>Unity中光源使用哪种渲染方式的依据
<ol>
<li>最亮的平行光按照逐像素处理</li>
<li>RenderMode设置成Important的光源会逐像素处理</li>
<li>RenderMode设置成Not Important的光源会逐顶点或者SH处理</li>
<li>如果根据以上规则得到的逐像素处理的光源数量少于QualitySetting中Pixel Light Count，则会有更多的光源按照逐像素处理。</li>
</ol>
</li>
<li>前向渲染的Shader实现<br>
<img src="https://singledigit9.github.io/post-images/1588580937528.jpeg" alt="" loading="lazy">
<ol>
<li>上图中两个编译指令必不可少，否则可能得到光照相关的值不正确。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>延迟渲染：</p>
<ol>
<li>原理：
<ol>
<li>第一个Pass不进行任何光照计算，仅仅计算那些片元是可见的。当一个片元是可见的，就将那个片元的颜色，平滑度，法线，自发光等信息存储到G缓冲区中。对于每个 物体来说，这个Pass只会执行一次。</li>
<li>第二个Pass，读取G缓冲区中的片元信息，比如表面法线，视角方向等，来进行光照计算。</li>
</ol>
</li>
<li>优点：
<ol>
<li>适合场景中光源很多，前向渲染会造成性能瓶颈的时候使用。</li>
<li>每个光源 都能够逐像素渲染</li>
</ol>
</li>
<li>缺点：
<ol>
<li>不支持真正的抗锯齿功能</li>
<li>不能处理半透明物体</li>
<li>对显卡有要求，要求支持MRT（Multiple Render Targets），Shader  Model 3.0以及以上，深度渲染纹理以及双面的模版缓冲。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>顶点照明渲染（这个新版Unity逐渐不再支持，暂时不研究了 。）</p>
</li>
</ol>
</li>
</ol>
<h4 id="光源">光源</h4>
<ol>
<li>光源的5个属性：位置，方向，颜色，强度，衰减</li>
<li>Unity中实时光源的几种类型
<ol>
<li>平行光</li>
<li>点光源</li>
<li>聚光灯</li>
</ol>
</li>
<li>Shader中区分光源
<ol>
<li>平行光：<code>#ifdef USING_DIRECTIONAL_LIGHT</code></li>
<li>点光源：<code>#if defined (POINT)</code></li>
<li>聚光灯：<code>defined (SPOT)</code></li>
</ol>
</li>
</ol>
<h4 id="unity的光照衰减">Unity的光照衰减</h4>
<ol>
<li>使用衰减纹理：Unity默认方式。一般而言，性能提升，效果大部分是良好的。
<ol>
<li>优点：计算简单</li>
<li>缺点：
<ol>
<li>需要预先采样纹理，&amp;纹理大小也会影响衰减精度</li>
<li>不直观，且一旦使用就无发使用其他的公式</li>
</ol>
</li>
<li>Shader中纹理的关键字：_LightTexture0（如果光源使用了cookies，那么应该使用_LightTextureB0）</li>
</ol>
</li>
</ol>
<h4 id="阴影">阴影</h4>
<ol>
<li>阴影是如何实现的
<ol>
<li>Shadow Map：将摄像机位置与 光源位置重合，那么摄像机看不到的地方就是应该显示阴影的地方。（Unity使用的是这种技术）</li>
</ol>
</li>
<li>前向渲染中，如果平行光开启了阴影，则Unity会为光源计算它的阴影映射纹理。这个纹理是一张 深度图，记录了从光源位置出发，能看到的场景中最近的表面位置（深度信息）。
<ol>
<li>如何记录表面位置信息
<ol>
<li>将摄像机放到光源位置，然后走正常的渲染流，得到深度信息。（但这种方式有性能浪费）</li>
<li>使用特殊的Pass，Tag标记LightMode为ShadowCaster。</li>
</ol>
</li>
<li>如何判定一个点在阴影里面：将点转换到光源空间下，对阴影纹理进行采样，如果采样的深度小于该点的深度，则这个点在阴影里面。</li>
</ol>
</li>
<li>Unity是如何显示最终的阴影的
<ol>
<li>屏幕空间的阴影映射技术（需要显卡支持，有些移动平台不支持这种特性）（原本是延迟渲染的阴影方法）</li>
<li>步骤：
<ol>
<li>调用ShadowCaster的Pass，生成光源的阴影纹理和摄像机的深度纹理</li>
<li>根据上面两个纹理生成屏幕空间的阴影图。如果摄像机的深度图中记录的表面深度大于转换到阴影映射纹理中的深度值，则说明表面虽然是可见的，但处于阴影中。</li>
</ol>
</li>
</ol>
</li>
<li>物体之间阴影的显示
<ol>
<li>想要接收：需要对阴影映射纹理进行采样，将采样的结果与最后的光照结果相乘。</li>
<li>想要投射：将物体加入到光源的阴影映射纹理计算中。（ShadowCaster的Pass）</li>
</ol>
</li>
<li>Unity中阴影的设置
<ol>
<li>Light检视面板：ShadowType选项，可以决定当前光源是否开启阴影</li>
<li>MeshRenderer检视面板：CastShadows和ReceiveShadows，决定是否产生和接收阴影。其中CastShadows还有TwoSided选项，可以决定该模型是否双面都产生阴影。</li>
</ol>
</li>
<li>UnityShader中阴影的三个关键字
<ol>
<li>SHADOW_COORDS(x)：用于Struct v2f中定义阴影深度纹理。其中x要看我们的TEXCOORD使用了几个，比如我已经用了TEXCOORD0，TEXCOORD1，那么x就写2</li>
<li>TRANSFER_SHADOW(o)：用于顶点着色器中生成阴影深度纹理</li>
<li>SHADOW_ATTENUATION(i)：用于片元着色器中读取阴影颜色（用来和最终颜色相乘）</li>
</ol>
</li>
<li>默认Shader中已经实现了阴影深度纹理的采集，可以直接使用Fallback来避免重复代码</li>
<li>半透明物体的阴影
<ol>
<li>Unity默认半透明物体不产生阴影。</li>
<li>可以设置FallBack上的Shader，将其改为不透明物体使用的Shader，来让它强制产生阴影。</li>
</ol>
</li>
</ol>
<h3 id="第十章-高级纹理">第十章 高级纹理</h3>
<h4 id="立方体纹理">立方体纹理</h4>
<ol>
<li>使用原理：使用立方体纹理需要一个三维矢量。这个矢量以立方体中心为原点，发出的射线与立方体面相交的点即为采样点。</li>
<li>优点：实现简单快速，效果也比较好</li>
<li>缺点：当场景中光源，物体发生变化时，往往需要重新生成立方体纹理。用于反射时，立方体不能模拟多次反射的效果。（因此尽量不要对凹面的物体使用立方体纹理）</li>
<li>应用：
<ol>
<li>天空盒子：
<ol>
<li>Unity中可在LightSetting中设置当前场景的天空盒子</li>
<li>如果摄像机想使用自己的天空盒子，可以往摄像机上添加SkyBox组建，再将天空盒子拖到对应的位置。</li>
</ol>
</li>
<li>反射：基本算法就是根据视线方向和顶点法线，计算光线方向，然后使用入射方向在立方体纹理上采样，将采样后的颜色与原来光照的颜色进行混合/覆盖等操作。
<ol>
<li>立方纹理的采样方法：texCUBE(_TexName, i.xyz)</li>
</ol>
</li>
<li>折射：
<ol>
<li>物理依据：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mi>s</mi><mi>i</mi><mi>n</mi><msub><mi>b</mi><mn>1</mn></msub><mo>=</mo><msub><mi>a</mi><mn>2</mn></msub><mi>s</mi><mi>i</mi><mi>n</mi><msub><mi>b</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_1sinb_1 = a_2sinb_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：各自材质中的折射率</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">b_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">b_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：光与法线的夹角</li>
</ol>
</li>
<li>对透明物体来说，计算完折射方向直接采样是符合物理实际的，因为光线入射有折射，出射还以折射。但在实时计算中，计算二次折射比较复杂 ，所以通常只计算一次折射。</li>
<li>使用：<code>refract(-normalize(o.worldViewDir), normalize(o.worldNormal), _RefractRatio)</code>可以计算折射，其中<code>_refractRatio</code>为折射率。</li>
</ol>
</li>
<li>菲涅尔反射
<ol>
<li>物理现象：低头看水面，能看到水底；看水的远处，只能看到倒影</li>
<li>近似公式：
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>v</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo><mo>=</mo><msub><mi>F</mi><mn>0</mn></msub><mo>+</mo><mo>(</mo><mn>1</mn><mo>−</mo><msub><mi>F</mi><mn>0</mn></msub><mo>)</mo><mo>(</mo><mn>1</mn><mo>−</mo><mi>v</mi><mo separator="true">⋅</mo><mi>n</mi><msup><mo>)</mo><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">F(v, n) = F_0 + (1 - F_0)(1 - v·n)^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>
<ol>
<li>v：视角方向</li>
<li>n：表面法线</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">F_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：反射系数</li>
</ol>
</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>v</mi><mo separator="true">,</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mi>b</mi><mi>i</mi><mi>a</mi><mi>s</mi><mo>+</mo><mi>s</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>e</mi><mo separator="true">⋅</mo><mo>(</mo><mn>1</mn><mo>−</mo><mi>v</mi><mo separator="true">⋅</mo><mi>n</mi><msup><mo>)</mo><mrow><mi>p</mi><mi>o</mi><mi>w</mi><mi>e</mi><mi>r</mi></mrow></msup><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">F(v, n) = max(0, min(1,bias + scale·(1 - v · n)^{power}))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
</ol>
</li>
<li>公式使用方法：
<ol>
<li><code>lerp(diffuse, reflection, saturate(fresnel)</code></li>
<li>有些实现也会把fresnel与反射结果相乘，饭后叠加到漫反射上。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>立方体纹理的创建
<ol>
<li>使用特殊布局的纹理（比如立方体的展开图），然后将TextureShape设置成Cube，并在里面下拉出的选项进行相应设置。</li>
<li>使用脚本来生成CubeMap。调用<code>Camera.RenderToCubeMap()</code>（经过测试，Mac上2018版本的Unity，一勾CubeMap的Readable就崩溃了）</li>
<li>创建一个CubeMap（这个是旧版本方法），将6张图按顺序拖进去。</li>
</ol>
</li>
</ol>
<h4 id="渲染纹理中间缓冲">渲染纹理（中间缓冲）</h4>
<ol>
<li>Unity获取渲染纹理的方式
<ol>
<li>创建RenderTexture</li>
<li>使用GrabPass或者OnRenderImage获取当前屏幕图像</li>
</ol>
</li>
<li>应用：
<ol>
<li>镜子效果：使用一个新相机和RenderTexture实现。Shader里面UV的x进行一下左右翻转。</li>
<li>玻璃效果：
<ol>
<li>使用GrabPass，抓取所有不透明的图像</li>
<li>计算偏移，取折射值<pre><code class="language-shader">i.scrPos.xy = offset * i.scrPos.z + i.scrPos.xy;//离屏幕越远，偏移越大
fixed3 refrCol = tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;//透视除法得到真正的屏幕坐标。
</code></pre>
</li>
<li>计算反射方向，采样，得到反射颜色值</li>
<li>反射和折射进行混合。</li>
</ol>
</li>
</ol>
</li>
<li>RenderTexture和GrabPass的对比
<ol>
<li>GrabPass：实现简单，但抓取的图像和设备分辨率一样，高分辨率设备影响尤其严重。</li>
<li>RenderTexture：效率高。尽管需要额外的摄像机进行渲染，但我们可以设置渲染的层级，RenderTexture的质量等方式来减少消耗 。</li>
</ol>
</li>
</ol>
<h4 id="程序纹理">程序纹理</h4>
<p>实际上就是代码创建Texture并且向其中每个像素填充颜色。</p>
<h3 id="第11章-让画面动起来">第11章 让画面动起来</h3>
<h4 id="应用">应用</h4>
<ol>
<li>序列帧动画</li>
<li>滚动背景</li>
<li>顶点动画
<ol>
<li>模型空间内坐标进行偏移</li>
<li>需要额外设置标签&quot;DisableBatching&quot;，防止Unity批处理导致顶点动画不正确</li>
</ol>
</li>
<li>广告牌：让它看起来总是对着摄像机。（比如角色血条）
<ol>
<li>视角方向和表面法线方向总有一个是固定的</li>
<li>通过公式计算出变换矩阵
<ol>
<li>right = up X  normal</li>
<li>up' = normal X right<br>
<img src="https://singledigit9.github.io/post-images/1588677932028.jpeg" alt="" loading="lazy"></li>
</ol>
</li>
<li>转换模型空间中顶点坐标</li>
<li>需要额外设置标签&quot;DisableBatching&quot;，防止Unity批处理导致顶点动画不正确</li>
</ol>
</li>
</ol>
<h4 id="unity和批导致顶点动画不正确的原因">Unity和批导致顶点动画不正确的原因</h4>
<p>Unity和批后，模型各自的模型空间会丢失。</p>
<h4 id="一些注意事项">一些注意事项</h4>
<ol>
<li>尽量避免使用模型空间下的一些绝对位置做计算。</li>
<li>有顶点动画的阴影效果往往需要自己额外实现</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity Shader中常用的变换矩阵]]></title>
        <id>https://singledigit9.github.io/post/unity-shader-zhong-chang-yong-de-bian-huan-ju-zhen/</id>
        <link href="https://singledigit9.github.io/post/unity-shader-zhong-chang-yong-de-bian-huan-ju-zhen/">
        </link>
        <updated>2020-05-04T07:33:20.000Z</updated>
        <content type="html"><![CDATA[<p>速记：M模型空间；V：观察空间；P：剪裁空间；I：逆矩阵；T：转置矩阵</p>
<ol>
<li>UNITY_MATRIX_MVP 模型空间-&gt;剪裁空间
<ol>
<li>新版函数 UnityObjectToClipPos(float4 v)</li>
</ol>
</li>
<li>UNITY_MATRIX_MV 模型空间-&gt;观察空间</li>
<li>UNITY_MATRIX_V 世界空间-&gt;观察空间</li>
<li>UNITY_MATRIX_P 观察空间-&gt;剪裁空间</li>
<li>UNITY_MATRIX_VP 世界空间-&gt;剪裁空间</li>
<li>UNITY_MATRIX_T_MV 模型空间到观察空间的逆矩阵
<ol>
<li>如果UNITY_MATRIX_MV是正交矩阵的话，那么这个矩阵就是它的逆矩阵。可以将观察空间的坐标变换到模型空间。（只旋转和统一缩放）</li>
</ol>
</li>
<li>UNITY_MATRIX_IT_MV 模型空间到观察空间的逆转矩阵
<ol>
<li>用于法线从模型空间变换到观察空间</li>
<li>用于求UNITY_MATRIX_MV的逆矩阵（直接转置一下就可以了）</li>
</ol>
</li>
<li>_Object2World：模型空间到世界空间</li>
<li>_World2Object：世界空间到模型空间
<ol>
<li>新版矩阵 unity_WorldToObject<br>
<img src="https://singledigit9.github.io/post-images/1588321197724.jpeg" alt="" loading="lazy"></li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity Shader中的属性]]></title>
        <id>https://singledigit9.github.io/post/unity-shader-zhong-de-shu-xing-ding-yi-he-chu-shi-hua/</id>
        <link href="https://singledigit9.github.io/post/unity-shader-zhong-de-shu-xing-ding-yi-he-chu-shi-hua/">
        </link>
        <updated>2020-05-04T07:30:31.000Z</updated>
        <content type="html"><![CDATA[<h3 id="properties定义和初始化">Properties定义和初始化</h3>
<p><code>_Int(&quot;Int&quot;, Int) = 2</code><br>
<code>_Float(&quot;Float&quot;, Float) = 1.4</code><br>
<code>_Range(&quot;Range&quot;, Range(0, 1)) = 0.5</code><br>
<code>_Color(&quot;Color&quot;, Color) = (1, 0, 0, 0)</code><br>
<code>_Vector(&quot;Vector&quot;, Vector) = (1, 2, 3, 4)</code><br>
<code>_2D(&quot;2D&quot;, 2D) = &quot;white&quot;{}</code>（&quot;bump&quot;是unity内置的法线纹理）<br>
<code>_Cube(&quot;Cube&quot;, Cube) = &quot;&quot;{}</code><br>
<code>_3D(&quot;3D&quot;, 3D) = &quot;&quot;{}</code></p>
<h3 id="shaderlab中属性和cg中类型的对应关系">ShaderLab中属性和CG中类型的对应关系</h3>
<table>
<thead>
<tr>
<th>ShaderLab属性</th>
<th>CG变量类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Color, Vector</td>
<td>float4, half4, fixed4</td>
</tr>
<tr>
<td>Range, Float</td>
<td>float, half, fixed</td>
</tr>
<tr>
<td>2D</td>
<td>sampler2D</td>
</tr>
<tr>
<td>Cube</td>
<td>samplerCube</td>
</tr>
<tr>
<td>3D</td>
<td>sampler3D</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity Shader中的语义]]></title>
        <id>https://singledigit9.github.io/post/unity-shader-zhong-de-yu-yi/</id>
        <link href="https://singledigit9.github.io/post/unity-shader-zhong-de-yu-yi/">
        </link>
        <updated>2020-05-04T07:29:07.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>应用阶段--&gt;顶点着色器
<ol>
<li>POSITION：模型空间中顶点的位置，常为float4</li>
<li>NORMAL：顶点法线，常为float3</li>
<li>TANGENT：顶点切线，常为float4</li>
<li>TEXCOORD[x]：其中x为大于等于0的数字，表示第几组纹理坐标
<ol>
<li>x最大值根据不同的ShaderModel版本变化。</li>
<li>一般情况下，一个模型的纹理坐标数不超过2。</li>
</ol>
</li>
<li>COLOR：顶点颜色，常为fixed4或者float4</li>
</ol>
</li>
<li>顶点着色器--&gt;片元着色器
<ol>
<li>SV_POSITION：裁剪空间中的顶点坐标</li>
<li>COLOR0：第一组顶点颜色，不是必须的</li>
<li>COLOR1：第二组顶点颜色，不是必须的</li>
<li>TEXCOORD0～TEXCOORD7：通常用于输出纹理坐标或者自定义数据。</li>
</ol>
</li>
<li>片元着色器--&gt;
<ol>
<li>SV_TARGET：输出值将会存储在渲染目标中。</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于Unity  Foreach的GC问题 ]]></title>
        <id>https://singledigit9.github.io/post/guan-yu-unity-foreach-de-gc-wen-ti/</id>
        <link href="https://singledigit9.github.io/post/guan-yu-unity-foreach-de-gc-wen-ti/">
        </link>
        <updated>2020-05-03T07:10:34.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="先说结论">先说结论</h3>
<p><strong>新版本Unity中，使用Foreach时已经不产生额外GC了</strong>。<br>
网上说是从5.6开始改的，这个没有经过验证，暂且存疑。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="先说结论">先说结论</h3>
<p><strong>新版本Unity中，使用Foreach时已经不产生额外GC了</strong>。<br>
网上说是从5.6开始改的，这个没有经过验证，暂且存疑。</p>
<!-- more -->
<h3 id="结论查找过程">结论查找过程</h3>
<p>起因是发现<code>List.ForEach</code>可能会很有用，能够减少不少多余代码。<br>
但因为一直在顾虑<code>Foreach</code>GC的问题，所以就像知道这个方法就不会产生额外GC。</p>
<p>于是我在Update里面分别用<code>for``foreach``List.ForEach</code>进行遍历，在Profiler中查看，发现没有额外的GC产生。<br>
刚开始还以为是自己使用Profiler的姿势不对，没找到应该看哪里。<br>
后来到Google查Unity Foreach GC，发现了这个问题的答案。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Unity Shader 入门精要》读书笔记（入门篇共4章）]]></title>
        <id>https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-ru-men-pian/</id>
        <link href="https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-ru-men-pian/">
        </link>
        <updated>2020-05-01T15:00:39.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="写在前面">写在前面</h3>
<p>内容比预想的要多，进度有些慢，一点点来吧。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="写在前面">写在前面</h3>
<p>内容比预想的要多，进度有些慢，一点点来吧。</p>
<!-- more -->
<hr>
<h3 id="第五章-开始unity-shader学习之旅">第五章 开始Unity Shader学习之旅</h3>
<p>这里记录一些基本概念类的知识，涉及到代码的，写在另一篇文章里，方便查阅。</p>
<h4 id="shader的一些基基础知识">Shader的一些基基础知识</h4>
<ol>
<li>顶点着色器是逐顶点调用的，片元着色器是逐片元调用的。片元着色器实际上是把顶点着色器的输入进行插值后得到的结果。</li>
<li>属性定义后，需要在CG代码块中定义一个类型匹配，名字相同的变量。</li>
<li><code>uniform</code>：表示变量初始化来自于外部程序，可以省略。</li>
<li><code>#include &quot;UnityCG.cginc&quot;</code>：类似于C++的include</li>
<li>语义：赋给输入和输出的字符串，字符串表达了参数的含义。语义可以让Shader知道从哪里读取数据，返回的是什么数据。
<ol>
<li>有些<code>SV</code>开头的语义，其中<code>SV</code>表示的是<strong>系统数值</strong></li>
</ol>
</li>
</ol>
<h4 id="shader的debug方法">Shader的Debug方法</h4>
<ol>
<li>将要调试的变量值转换到（0，1），并用单颜色或者多颜色进行输出显示。</li>
<li>需要注意的是，<strong>颜色分量大于1的会等于1，小于0的会等于0</strong></li>
</ol>
<h4 id="注意渲染平台的差异">注意渲染平台的差异</h4>
<ol>
<li>渲染纹理坐标差异
<ol>
<li>OpenGL，原点在左下角</li>
<li>DX，原点在左上角</li>
<li>通常情况下，Unity会根据平台自动进行翻转。但是有一种特殊情况：Unity Quality设置开启了抗锯齿，处理多张渲染图像时，DX垂直方向的朝向可能不同，需要手动翻转。<pre><code class="language-shader">#if UNITY_UV_STARTS_AT_TOP // 判断当前平台是不是DX平台 
if (_MainTex.TexelSize.y &lt; 0)
{
    uv.y = 1 - uv.y;
}
#endif
</code></pre>
</li>
</ol>
</li>
<li>语法差异
<ol>
<li>简单来说，DX的语法要求更加严格，为了使自己的Shader代码跨平台性更好，写代码时要注意规范。
<ol>
<li>要求变量初始化参数数量必须严格匹配，<code>float3(1)</code>这种初始化方式是不允许的。</li>
<li>要求带有 out 关键字的参数必须被初始化。<pre><code class="language-shader">UNITY_INITIALIZE_OUTPUT([类型], [变量名])//使用Unity内置的宏对输出结构体进行初始化
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="shader代码注意事项">Shader代码注意事项</h4>
<ol>
<li>float，half，fixed的选择：尽可能选用低精度的
<ol>
<li>PC的GPU会把所有的浮点数按照最高京都市进行计算==&gt;PC上基本看不出差别</li>
<li>移动平台GPU上，会有不同的精度和计算速度的差别。所以<strong>一定要在移动平台验证Shader</strong>。</li>
<li>大多数现代GPU上，half和fixed是等价的。</li>
</ol>
</li>
<li>规范语法。使用和变量类型匹配的参数数目来对变量进行初始化。</li>
<li>避免不必要的计算。大量计算会导致Shader报错。</li>
<li>慎用分支语句和循环语句
<ol>
<li>GPU实现分支语句和CPU不同，最坏的情况，执行一个分之语句的时间相当于执行了所有分之的时间。<strong>分支语句会降低GPU的并行操作</strong>。</li>
<li>复杂计算考虑把计算往上移：片元着色器--&gt;顶点着色器--&gt;CPU。（<strong>顶点比片元少</strong>）</li>
<li>不能避免的分支语句时
<ol>
<li>条件变量最好是常数</li>
<li>每个分支中进行的操作尽可能少</li>
<li>分支嵌套层数尽可能少</li>
</ol>
</li>
</ol>
</li>
<li>不要除以0，可能在不同平台有不同表现的错误。
<ol>
<li>一个解决方法就是将可能为0的除数的强制截取到非0的范围</li>
</ol>
</li>
</ol>
<hr>
<h3 id="第六章-unity中的基础光照">第六章 Unity中的基础光照</h3>
<h4 id="光照模型的物理依据">光照模型的物理依据</h4>
<ul>
<li>吸收和散射
<ol>
<li>散射改变光的方向，但不改变光的颜色和密度。
<ol>
<li>光经过物体表面进行散射时，一部分散射到内部——折射或者投射；一部分散射到外部——反射。</li>
<li>对于不透明的物体，折射进物体内部的光线会继续与物体内部的颗粒进行相交，其中一部分光线会重新发射出物体表面，而另外一部分被物体吸收</li>
</ol>
</li>
<li>吸收只改变光的颜色和密度，不改变光的方向。</li>
<li>高光反射Specular：物体表面如何反射光线</li>
<li>漫反射Diffuse：有多少光线会被折射，吸收和散射出表面。</li>
</ol>
</li>
</ul>
<h4 id="光照模型">光照模型</h4>
<p>光照模型实际上是一个平衡了计算速度和表现效果经验模型。</p>
<ul>
<li>标准光照模型：将光线分成四个部分
<ol>
<li>自发光emissive
<ol>
<li>物体自己的发光</li>
</ol>
</li>
<li>高光反射specular
<ol>
<li>是一种经验模型，并不完全符合真是世界中的高光反射。</li>
<li>Phong模型：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>r</mi></mrow></msub><mo>=</mo><mo>(</mo><msub><mi>c</mi><mrow><mi>l</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow></msub><mo separator="true">⋅</mo><msub><mi>m</mi><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>r</mi></mrow></msub><mo>)</mo><mo separator="true">⋅</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>v</mi><mo separator="true">⋅</mo><mi>r</mi><msup><mo>)</mo><msub><mi>m</mi><mrow><mi>g</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>s</mi></mrow></msub></msup></mrow><annotation encoding="application/x-tex">c_{specular}=(c_{light}·m_{specular})·max(0, v·r)^{m_{gloss}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29011428571428566em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mrow><mi>g</mi><mi>l</mi><mi>o</mi><mi>s</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">m_{gloss}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>：光泽度，控制亮点宽度</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">m_{specular}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>：高光反射颜色</li>
<li>r：反射方向</li>
<li>v：观察方向</li>
</ol>
</li>
<li>Blinn模型：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>r</mi></mrow></msub><mo>=</mo><mo>(</mo><msub><mi>c</mi><mrow><mi>l</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow></msub><mo separator="true">⋅</mo><msub><mi>m</mi><mrow><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>r</mi></mrow></msub><mo>)</mo><mo separator="true">⋅</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo separator="true">⋅</mo><mi>h</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">c_{specular}=(c_{light} · m_{specular}) · max(0, n · h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>
<ol>
<li>n：法线方向</li>
<li>h：法线和光源方向的夹角方向的单位向量</li>
</ol>
</li>
<li>摄像机和光源里物体足够远时，使用Blinn模型比较块，这是因为观察方向和光源方向可以认为是定值。当观察方向和光源方向不是定值时，Phong模型可能更快。</li>
</ol>
</li>
<li>漫反射diffuse
<ol>
<li>兰伯特定律：反射光线的强度和表面法线与光源方向之间夹角的余弦成正比。</li>
<li>兰伯特光照模型：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>=</mo><mo>(</mo><msub><mi>c</mi><mrow><mi>l</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow></msub><mo separator="true">⋅</mo><msub><mi>m</mi><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>)</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo separator="true">⋅</mo><mi>I</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">c_{diffuse}=(c_{light}·m_{diffuse})max(0, n·I)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mclose">)</span></span></span></span>
<ol>
<li>I：光源方向</li>
</ol>
</li>
<li>半兰伯特光照模型：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>c</mi><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>=</mo><mo>(</mo><msub><mi>c</mi><mrow><mi>l</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow></msub><mo separator="true">⋅</mo><msub><mi>m</mi><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi></mrow></msub><mo>)</mo><mo>(</mo><mi>a</mi><mo>(</mo><mi>n</mi><mo separator="true">⋅</mo><mi>I</mi><mo>)</mo><mo>+</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">c_{diffuse}=(c_{light}·m_{diffuse})(a(n·I)+b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>
<ol>
<li>其中a，b常常取0.5</li>
<li>这个模型是为了解决兰伯特模型上背光区显示为黑，失去细节展现的问题。</li>
<li>这个模型没有物理依据，仅仅是为了视觉加强。</li>
</ol>
</li>
</ol>
</li>
<li>环境光ambient
<ol>
<li>一个物体收到其他物体的反射投射光影响的光照情况</li>
</ol>
</li>
</ol>
</li>
</ul>
<h4 id="关于光照的计算位置">关于光照的计算位置</h4>
<p>光照计算可以在片元着色器中，也可以在顶点着色器中，分别被称为逐片元光照和逐顶点光照。由于顶点数目往往小于像素数目，所以逐顶点光照的消耗通常要小于逐片元光照。因为逐顶点光照依赖插值来得到最终的像素光照，所以当光照中有非线性计算时（比如高光反射），逐顶点光照的表现就会有问题。一般高光会相对较暗，有些情况下可能会有棱角。</p>
<h4 id="unity中关于环境光的特殊设置">Unity中关于环境光的特殊设置</h4>
<p>Unity中环境光可以在Light界面中进行设置。（Windows-&gt;Rendering-&gt;Lighing）</p>
<hr>
<h3 id="第七章-基础纹理">第七章 基础纹理</h3>
<h4 id="shader中纹理属性的特殊定义">Shader中纹理属性的特殊定义。</h4>
<ol>
<li><strong>除了在CG中定义纹理<code>sampler2D _MainTex</code>以外，还需要定义<code>float4 _MainTex_ST</code>。</strong></li>
<li><code>float4 _MainTex_ST</code>的名字是有规范的。规范格式为<code>float4 [纹理字段名字]_ST</code>。</li>
<li>其中ST中的S代表缩放，T代表平移</li>
<li>xy存储的是缩放值，zw存储的是偏移值。</li>
</ol>
<h4 id="unity中关于纹理的一些基础知识和设置">Unity中关于纹理的一些基础知识和设置</h4>
<ol>
<li>Unity中的纹理坐标（UV坐标）是以左下角为原点的。</li>
<li>Unity中的纹理：纹理导入Unity后，检视面板上有一些关于纹理的细节设置。<br>
<a href="https://docs.unity3d.com/ScriptReference/TextureWrapMode.html"><em>TextureWrapMode</em></a>
<ol>
<li>WrapMode：设置当纹理坐标超过[0, 1]后，如何平铺该纹理
<ol>
<li>Repeat：如果纹理大于1，将直接使用小数部分进行显示（uv在[0, 1]之间循环）==&gt;不断重复</li>
<li>Clamp：如果纹理UV大于1，会被截取到1；如果小于0，则会被截取到0。</li>
<li>Mirror：镜像。UV在[0, 1][1, 0]之间重复</li>
<li>MirrorOnce：镜像一次。这个有跨平台问题。UV在[-1, 1]之间时使用Mirror的规则，超出范围则强制取最大最小范围值。</li>
</ol>
</li>
<li>Filter Mode：决定纹理因为变换而产生拉伸时，使用哪种滤波形式。（从上到下，效果增加，消耗增加）<br>
纹理滤波会影响放大缩小纹理时所使用的图片质量。
<ol>
<li>Point：采样像素只有一个。放大的图片会有比较明显的像素颗粒感。</li>
<li>Bilinear：采样像素为临近四个，然后线性插值。这会导致放大的图片会变得模糊。</li>
<li>Trilinear：除了Bilinear操作外，还会在渐远多级纹理之间进行混合。如果纹理没有使用多级渐远纹理技术，则最终的效果和Bilinear一样。</li>
</ol>
</li>
<li>多级渐变纹理mipmapping
<ol>
<li>预先生成降级采样的缩小的图片，在实时显示时，可以直接选取对应的图片进行显示，而不用额外计算。</li>
<li>通常会多占33%的空间。</li>
</ol>
</li>
<li>导入的图片可以不是正方形的，但长宽应该时2的n次幂。如果使用非2的n次幂的图片，往往会占据更大的空间，GPU读取纹理的速度也会下降。</li>
<li>纹理的压缩格式要根据实际情况进行选择。比如一张图片要求的精确显示，则可以考虑将它设置成高压缩的格式，以减少内存的占用。在图片不需要alpha通道时，选取去除alpha的压缩格式，来减少内存占用。</li>
</ol>
</li>
</ol>
<h4 id="凹凸映射">凹凸映射</h4>
<ol>
<li>高度映射
<ol>
<li>使用高度纹理模拟表面位移，计算得到修改后的法线值。</li>
<li>高度纹理存储的时强度值。</li>
<li>优点：直观</li>
<li>缺点：计算复杂，不能直接得到法线信息，需要根据计算像素的灰度来计算得出。从而消耗更多性能。</li>
</ol>
</li>
<li>法线纹理：
<ol>
<li>直接使用法线纹理存储表面法线。</li>
<li>法线方向和像素之间的转换公式：
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>x</mi><mi>e</mi><mi>l</mi><mo>=</mo><mo>(</mo><mi>n</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>l</mi><mo>+</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">pixel = (normal + 1)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>l</mi><mo>=</mo><mi>p</mi><mi>i</mi><mi>x</mi><mi>e</mi><mi>l</mi><mo>∗</mo><mn>2</mn><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">normal = pixel * 2 - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
</ol>
</li>
<li>法线纹理的类型（优缺点要对比着看）：一般都使用切线空间下的法线纹理
<ol>
<li>基于模型空间的法线纹理：以模型空间为基准
<ol>
<li>优点：
<ol>
<li>简单直观。计算更少，生成方便。</li>
<li>缝合处和尖锐的部分可见缝隙少，能够提供光滑的边界。（因为法线纹理和贴图纹理所在的空间一致，可以通过插值来实现平滑的变换）</li>
</ol>
</li>
<li>缺点：
<ol>
<li>记录的时绝对法线，不能复用。</li>
<li>无法使用法线UV动画</li>
<li>需要存储xyz所有值，无法压缩</li>
</ol>
</li>
</ol>
</li>
<li>基于切线空间的法线纹理：以各自顶点为原点，以切线方向为x轴，副切线（或者副法线）为y轴，法线方向为z轴的空间。
<ol>
<li>优点：
<ol>
<li>自由度高。记录的是相对法线信息，可以将它用在不同的网格上。</li>
<li>可以使用法线来做UV动画来实现凹凸移动效果。</li>
<li>可复用。</li>
<li>可压缩。因为切线空间中法线的z方向始终是正方向，所以我们可以通过xy只来计算z方向的值。</li>
</ol>
</li>
<li>缺点：
<ol>
<li>缝合处和边缘尖锐出坑有缝隙</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>世界空间下副切线的计算步骤<pre><code class="language-shader">fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);
fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
</code></pre>
<ol>
<li>v.tangent.w：由模型编辑软件自动生成。</li>
<li>unity_WorldTransformParams.w：该参数在UnityShaderVariables.cginc中。
<ol>
<li>自带的注释：<code>w is usually 1.0, or -1.0 for odd-negative scale transforms</code></li>
<li>模型Scale值xyz，有奇数个为负，则w为负。（目前个人理解是因为模型因为Scale镜像翻转了）</li>
</ol>
</li>
<li>参考资料：<a href="https://zhuanlan.zhihu.com/p/103546030"><em>关于顶点的法线、切线、副切线</em></a></li>
</ol>
</li>
<li>可以将光线方向和观察方向转到切线空间中进行计算，也可以将法线贴图中的到的法线转到世界空间中进行计算。</li>
<li>Unity中法线纹理的设置。设置成Normal Map
<ol>
<li>可以针对不同平台设置不同的压缩格式。</li>
<li>有一个CreateFromGrayscale选项，用于从高度图生成法线纹理图。
<ol>
<li>Bumpiness：控制凹凸程度</li>
<li>Filtering：使用哪种算法生成法线纹理。smooth比较平滑，sharp使用了边缘检测来生成法线。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="渐变纹理">渐变纹理</h4>
<ol>
<li>原来的漫反射公式中，漫反射颜色参数是一个定值</li>
<li>在使用渐变纹理时，漫反射颜色是动态在渐变贴图中采样的。</li>
<li>依据参数就是漫反射光照模型公式中的常数量（法线和光照的点积）</li>
</ol>
<h4 id="遮照纹理">遮照纹理</h4>
<ol>
<li>使用流程
<ol>
<li>采样遮照纹理</li>
<li>使用某个或者某几个颜色值，与某种表面属性相乘。</li>
<li>一般来讲，当上面的结果为0时，这个表面属性就不起作用了。</li>
</ol>
</li>
<li>优点
<ol>
<li>可以让美术人员更加精准的控制模型表面的各种属性。</li>
</ol>
</li>
<li>在实际开发的过程中，要充分利用贴图的rgba属性。比如r存储高光反射遮照，g存储边缘光照强度，b存储自发光，a存储高光反射指数部分等等。</li>
</ol>
<hr>
<h3 id="第八章-透明效果">第八章 透明效果</h3>
<h4 id="unity中实现透明的两种方式">Unity中实现透明的两种方式</h4>
<p><strong>透明度测试</strong>和<strong>透明度混合</strong></p>
<h4 id="透明度测试">透明度测试</h4>
<ul>
<li>只要某个片元没有通过测试，则该片元直接被舍弃==&gt;产生的效果是要么完全透明，要么完全不透明</li>
</ul>
<h4 id="透明度混合">透明度混合</h4>
<ol>
<li>透明度混合：能够真正得到半透明效果。但需要<strong>关闭深度写入</strong>。因此要格外注意渲染顺序。
<ol>
<li>如果不关闭深度写入，那么透明物体后面的物体会因为深度测试而被剔除掉。</li>
</ol>
</li>
<li>书上关于不同渲染顺序与显示结果的影响的说明（A半透明，B不透明）<br>
<img src="https://singledigit9.github.io/post-images/1588512225204.jpeg" alt="" loading="lazy"></li>
<li>一般引擎解决渲染排序的方法
<ol>
<li>先渲染所有不透明物体，并开启深度测试和深度写入</li>
<li>把半透明物体按照离摄像机远近进行排序，然后按照从后向前的顺序进行渲染。开启深度测试，关闭深度写入。</li>
</ol>
</li>
<li>Unity解决渲染排序的方法 ：在Tags中使用<strong>Queue</strong>。需要注意的是，<strong>透明度混合需要关闭深度写入</strong></li>
<li>透明度混合需要使用Blend指令。Blend命令设置了混合的计算方法。具体的指令写在另一篇文章里，方便查阅。</li>
</ol>
<h4 id="自带交叉的模型的透明度渲染">自带交叉的模型的透明度渲染</h4>
<ol>
<li>第一个Pass进行深度写入，但不输出颜色。</li>
<li>第二个Pass关闭深度写入，进行正常的透明度颜色混合。</li>
</ol>
<h4 id="透明物体的双面渲染关键字-cull">透明物体的双面渲染（关键字 Cull）</h4>
<ol>
<li>第一个Pass先渲染背面</li>
<li>第二个Pass再渲染正面</li>
</ol>
]]></content>
    </entry>
</feed>