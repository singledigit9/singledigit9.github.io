<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://singledigit9.github.io</id>
    <title>资料库</title>
    <updated>2020-09-12T16:32:24.306Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://singledigit9.github.io"/>
    <link rel="self" href="https://singledigit9.github.io/atom.xml"/>
    <subtitle>One By One</subtitle>
    <logo>https://singledigit9.github.io/images/avatar.png</logo>
    <icon>https://singledigit9.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 资料库</rights>
    <entry>
        <title type="html"><![CDATA[LockStepFramework 帧同步框架学习]]></title>
        <id>https://singledigit9.github.io/post/lockstepframework-zheng-tong-bu-kuang-jia-xue-xi/</id>
        <link href="https://singledigit9.github.io/post/lockstepframework-zheng-tong-bu-kuang-jia-xue-xi/">
        </link>
        <updated>2020-09-12T15:51:55.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="写在前面">写在前面</h2>
<p>最近说实话比较咸鱼，同时又有些沉迷魔兽无法自拔，所以自我学习的进度上，相比之前有些放缓。<br>
但好在还没有停下，断断续续学了一些东西，虽然也有记笔记，但只是简单的记录了一下而已，没有进一步的消化吸收，这里就二次整理一下。<br>
也简单说一下为什么要看帧同步这块的东西吧，主要是因为工作中的物理同步，确实写的有很大问题，但项目已经到了末期，没法改了，只能各种吐槽&amp;&amp;捏着鼻子用了。加上这块我确实之前没有搞过，所以上网搜了下帧同步的一些东西，找到了这个框架。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="写在前面">写在前面</h2>
<p>最近说实话比较咸鱼，同时又有些沉迷魔兽无法自拔，所以自我学习的进度上，相比之前有些放缓。<br>
但好在还没有停下，断断续续学了一些东西，虽然也有记笔记，但只是简单的记录了一下而已，没有进一步的消化吸收，这里就二次整理一下。<br>
也简单说一下为什么要看帧同步这块的东西吧，主要是因为工作中的物理同步，确实写的有很大问题，但项目已经到了末期，没法改了，只能各种吐槽&amp;&amp;捏着鼻子用了。加上这块我确实之前没有搞过，所以上网搜了下帧同步的一些东西，找到了这个框架。</p>
<!-- more -->
<h2 id="资料地址">资料地址</h2>
<p>https://github.com/SnpM/LockstepFramework.git</p>
<h2 id="正文内容">正文内容</h2>
<p>首先来说，Unity内置的PhyX是做不了帧同步的，因为PhyX，相同的初始条件，在不同的机器上计算结果可能不一样。这个我是做过测试的，一个方块平抛撞墙落地上，输出落地坐标。PC包和Unity编辑器的结果是一样的，APK包在模拟器上跑的结果就不一样了。想要帧同步，就需要找另一个物理引擎或者自己根据需求写一个。<br>
其次，计算一定要用定点数。下面正式开始笔记内容。</p>
<h3 id="定点数的实现">定点数的实现</h3>
<ol>
<li>使用<code>long</code>，高16位为整数部分，低16位为小数部分</li>
<li>定点数之间的运算，大多使用位运算，增加运算效率。</li>
</ol>
<p>之前自己对定点数的想法只是简单的将数字放大多少倍发送出去，然后另外一边将接收数字再缩小相同倍数之后计算。这个想法是错误的，有问题的。浮点数计算不准确的原因就是在于计算的过程中使用了浮点数，而我的之前的想法中实际计算的时候还是浮点数进行的计算。此外，简单的将数字放大，然后用整数计算，最后再缩小也是有问题的，中间涉及到乘除的时候，缩小倍数就不好确定了。</p>
<h2 id="fastcollection">FastCollection</h2>
<p>这是一个第三方的集合库，内部把list什么的都实现了一遍。但是，我对比了一下C#的list代码和这个库的list代码，发现内部逻辑都是一样的啊。内部建立数组，然后填充数据不够的时候对内部数组进行扩容。所以我不是很理解为什么要用这个库。但还是有个东西很不错值得记录一下的。</p>
<ol>
<li>有个BiDictionary实现的特别好，就是那种Key值heValue值需要互相索引的字典，这个字典继承了原字典，然后将value值key值在存储一份。获取方便。</li>
</ol>
<h2 id="message">Message</h2>
<ol>
<li>和自己平常写的订阅发布相比，每个类型的Message进行了单独的封装<code>messageChannel</code>，用来管理自己这个消息的分发等等。就是把<code>Dictionary&lt;key,List&lt;value&gt;&gt;</code>的结构数据结构化了一下。<code>Manager</code>使用字符串作为<code>key</code>值索引<code>messageChannel</code>。</li>
</ol>
<h2 id="数据读取写入">数据读取写入</h2>
<p>框架中的数据解析是从byte中直接流式读取的，自己记录当前byte数组中的读取位置，相比与传统的json解析什么的效率更高。</p>
<h2 id="数据收发">数据收发</h2>
<h3 id="流程">流程</h3>
<ol>
<li>发送就是正常的每帧发送同步数据</li>
<li>因为自己实现了<code>byte[]</code>读取写入的东西，所以收发直接用的<code>byte[]</code></li>
<li>tick中每两帧处理一次接收的数据（向内部转发处理），同时将接收的数据清除。</li>
<li>发送的原始数据到数据处理端进行处理。（数据的处理）
<ol>
<li>校验，长度不够的直接舍弃。</li>
<li>提取帧数信息，当前是第几帧。</li>
<li>使用剩余的字节提取当前帧数命令信息。
<ol>
<li><code>Activator.CreateInstance</code>根据类型直接创建对象（当前帧的Command类型是直接发过来的，然后解析byte数组解析出类型，再使用这个类型直接创建Command对象）</li>
<li>读取数据（Command内部有读取数据接口，读取数组数据内容，填充自己，并将当前的索引位置进行记录返回）</li>
</ol>
</li>
<li>将命令添加到当前帧数中（解析完一个Command就将一个Command加入一个帧对象中）</li>
</ol>
</li>
<li>将当前帧放入帧数管理器
<ol>
<li>如果已经有当前的帧数Id了，则新的帧数数据直接舍弃</li>
</ol>
</li>
<li>在FixUpdate中执行当期帧的所有命令</li>
</ol>
<h3 id="简单的数据结构包含关系">简单的数据结构包含关系</h3>
<ul>
<li>Frame
<ul>
<li>Id</li>
<li>Command</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《游戏设计模式》读书笔记——序列模式]]></title>
        <id>https://singledigit9.github.io/post/lesslessyou-xi-she-ji-mo-shi-greatergreater-du-shu-bi-ji-xu-lie-mo-shi/</id>
        <link href="https://singledigit9.github.io/post/lesslessyou-xi-she-ji-mo-shi-greatergreater-du-shu-bi-ji-xu-lie-mo-shi/">
        </link>
        <updated>2020-07-31T05:53:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1>
<p>这部分主要是介绍了一些游戏中有关时序之类的设计模式。现在的引擎封装的都很好，基本上用不到这些。<br>
但还是需要做一些了解，万一有需求需要的话知道大概该怎么做。</p>
<h1 id="双缓冲模式">双缓冲模式</h1>
<h2 id="个人理解">个人理解</h2>
<p>为了解决不同线程见访问同一块内存数据，有可能获取到错误数据的问题。<br>
但对内存苛刻的设备上就不好用这个了。</p>
<h2 id="简单描述">简单描述</h2>
<p>保存了下一个缓冲和当前缓冲。读取始终从当前缓冲读取。写入都写入下一个缓冲，写入完毕后将下一个缓冲和当前缓冲进行交换。</p>
<h2 id="注意事项">注意事项</h2>
<ol>
<li>双缓冲模式是位于底层的，外部不应该接触到双缓冲的内部逻辑</li>
<li>两个缓冲交换是需要一定时间的，一般是直接交换指针（引用）。如果交换的时间过长，那么双缓冲就失去意义了。</li>
<li>需要注意浅复制，不要让外部的代码存储对双缓冲的永久引用。</li>
</ol>
<h1 id="游戏循环">游戏循环</h1>
<h2 id="定义">定义</h2>
<p>游戏循环在游戏运行过程中不断运行。每次循环，都能够无阻塞的处理玩家输入，更新游戏状态，渲染状态。并且能够控制游戏速度。</p>
<h2 id="其他">其他</h2>
<p>每一帧中处理的数据不要过大，不然会影响游戏的运行速度。</p>
<h1 id="更新方法">更新方法</h1>
<h2 id="定义-2">定义</h2>
<p>每个对象实现一个更新方法来模拟当前对象在这一帧中的行为状态。</p>
<h2 id="个人理解-2">个人理解</h2>
<p>这个东西就比较常用了，Unity中的Update和自己平时写的其他的好多代码都用到了这个东西。还是尽可能让对象自己管自己的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《游戏编程模式》读书笔记——基础设计模式]]></title>
        <id>https://singledigit9.github.io/post/lesslessyou-xi-bian-cheng-mo-shi-greatergreater-du-shu-bi-ji-ji-chu-she-ji-mo-shi/</id>
        <link href="https://singledigit9.github.io/post/lesslessyou-xi-bian-cheng-mo-shi-greatergreater-du-shu-bi-ji-ji-chu-she-ji-mo-shi/">
        </link>
        <updated>2020-07-30T03:05:58.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="写在前面">写在前面</h1>
<p>这本书是半个月前开始看的吧，主要是觉得作者是一个资深的游戏开发，有些设计模式的东西游戏确实和其他的一些应用软件不一样，看下来应该会有所收获。<br>
此外个人觉得，设计模式这个东西，不在于死记硬背生搬硬套。而在于当遇到某个问题的时候，设计模式能够给你一个原始的思路，使你的代码实现能够尽可能满足需求和未来可能的变化。<br>
ps. 这些设计模式是在新模块制作的时候用的，一般写业务逻辑大概率用不上，注意可复用的逻辑代码和表现代码分离就好了。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1>
<p>这本书是半个月前开始看的吧，主要是觉得作者是一个资深的游戏开发，有些设计模式的东西游戏确实和其他的一些应用软件不一样，看下来应该会有所收获。<br>
此外个人觉得，设计模式这个东西，不在于死记硬背生搬硬套。而在于当遇到某个问题的时候，设计模式能够给你一个原始的思路，使你的代码实现能够尽可能满足需求和未来可能的变化。<br>
ps. 这些设计模式是在新模块制作的时候用的，一般写业务逻辑大概率用不上，注意可复用的逻辑代码和表现代码分离就好了。</p>
<!-- more -->
<h1 id="命令模式">命令模式</h1>
<h2 id="个人理解">个人理解</h2>
<p>就是将要执行的具体行为进行封装，交由想执行这个行为的角色执行，而不是直接执行。</p>
<h2 id="优点">优点</h2>
<p>将具体的行为进行封装，从而使目标和目标的行为进行分离，方便对目标行为进行扩展。</p>
<h2 id="能够做什么">能够做什么</h2>
<ol>
<li>输入系统</li>
<li>AI系统（和输入系统一样，只不过触发方式变了一下）</li>
<li>能够方便的进行撤销操作。（每个Command实现撤销方法，然后使用List记录Command顺序）</li>
<li>回放系统。</li>
</ol>
<h1 id="原型模式">原型模式</h1>
<p>这个书里面讲的感觉不是很好，绕晕了。</p>
<h2 id="个人理解-2">个人理解</h2>
<p>每个对象实现自己的clone方法，然后使用获取器对缓存的对象进行<strong>复制</strong>。</p>
<h2 id="与工厂模式的区别">与工厂模式的区别</h2>
<p>工厂模式直接<code>new</code>对象，并对它进行初始化设置。<br>
原型模式直接使用已经有的对象进行<strong>复制</strong>。<br>
一个是创建，一个是复制。</p>
<h2 id="适用范围">适用范围</h2>
<p>大对象的创建。大的对象往往复制会比创建更快。</p>
<h1 id="状态模式">状态模式</h1>
<h2 id="优点-2">优点</h2>
<p>状态模式将各种不同状态的操作进行隔离，避免大量的标记量和if判断。</p>
<h2 id="包含内容">包含内容</h2>
<p>状态Node的进入，离开，触发，以及当前Node可以去的Node。（Node的图的连接方向，这个之前自己写的东西没有弄这个）</p>
<h2 id="有限状态机">有限状态机</h2>
<ol>
<li>预先知道所有状态的集合</li>
<li>同一时间只能有一个状态</li>
<li>Node核心要素：
<ol>
<li>状态：</li>
<li>输入：对外部输入作出反应，比如执行纯逻辑，或者切换状态什么的</li>
<li>转移：知道自己能够切换到哪个Node上去</li>
</ol>
</li>
</ol>
<h2 id="分层状态机">分层状态机</h2>
<p>状态机中的Node使用继承。当前Node如果处理不了当前状态的话，将处理丢给父类。</p>
<h2 id="下推状态机">下推状态机</h2>
<p>将有限状态机中的当前状态的保存换为一个栈，这样当当前栈顶的状态执行完毕后，可以恢复到上一个状态。（实际上就是额外增加了一个记录）</p>
<h2 id="个人理解-3">个人理解</h2>
<p>状态模式这个东西用的很多了。一般情况下，有限状态机足够用了。其余的有些奇奇怪怪需求的稍微变种一下就可以。</p>
<h1 id="享元模式">享元模式</h1>
<ol>
<li>享元模式不是什么简单的对象池，而是多个对象共享相同的一个对象数据。</li>
<li>通过共享部分数据，减少数据的创建和数据的冗余。</li>
</ol>
<h1 id="观察者模式">观察者模式</h1>
<ol>
<li>这个粗暴些描述就是C#中的event。平时总是各种用，就不再细写了。</li>
<li>需要注意的就是注册过后要及时解注册，不然可能会有一些对象因为异常引用而无法释放。</li>
</ol>
<h1 id="单例模式">单例模式</h1>
<h2 id="使用单例模式的原因">使用单例模式的原因</h2>
<ol>
<li>没被使用时，不用初始化创建对象。</li>
<li>运行时初始化，可以控制初始化顺序。</li>
<li>可以使用可继承单例来实现一些特殊功能。比如不同平台的加载系统Log系统。</li>
</ol>
<h2 id="不使用单例的原因">不使用单例的原因</h2>
<ol>
<li>增加理解代码的难度。
<ol>
<li><strong>只使用局部变量的函数叫纯函数，纯函数往往利于理解，利于编译器优化。</strong></li>
<li>如果使用了全局变量，一旦因为全局变量出现了Bug，那么你就得在几十上百个引用中查找究竟是哪一个引用导致了全局变量的错误。</li>
</ol>
</li>
<li>增加代码耦合的可能性。做新功能的时候，往往会因为代码不熟悉或者想懒得动手动脑而采取最简单的方式来做东西。但这种情况下，单例模式因为提供了全局的访问接口，所以可以在各个系统中进行访问，从而导致一些不该有依赖关系的系统产生依赖关系。
<ol>
<li>比如《群星守卫》中，Server数据处理的位置有些地方和界面耦合，严谨些写的话应该拆开的。比如HandleServerMsg里面调用两个函数，一个HandleServerData，一个HandleServerView。不过毕竟还是少，这么写还算能够理解。</li>
</ol>
</li>
<li>对并行不友好。</li>
</ol>
<h2 id="单例的问题所在">单例的问题所在</h2>
<ol>
<li>存在唯一的实例和对所有人开方访问是两个完全不相关的问题。但单例把这两个强行绑定了。</li>
<li>延迟创建确实用起来很方便，但也某种意义上让我们丧失了对单例对象的创建的控制。</li>
</ol>
<h2 id="避免滥用单例的方法">避免滥用单例的方法</h2>
<ol>
<li>去除没有必要的管理类。数量过多的管理类只能说明作者对oop不够熟悉。<strong>oop的核心就是让对象自己管好自己</strong>。</li>
<li>可使用<code>assert</code>之类的断言来防止多个创建。（不该多个创建的地方多个创建了，说明这块使用的有问题，有问题就应该直接报错，暴露出来解决掉。）</li>
<li>将对象作为参数传进来。</li>
<li>将对象的访问从基类进行继承。</li>
<li>让不能避免的全局入口携带对象。（这个看个人习惯，不能完全照搬）</li>
</ol>
<h2 id="个人感想">个人感想</h2>
<p>单例一样特别常用，但说实话，我个人并不喜欢。<br>
游戏中的单例往往都是游戏初始化时创建，然后游戏结束销毁。<br>
但既然它全局存在，为啥不用静态类呢？写代码的时候少敲一个GetInstance不舒服么？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++视频学习笔记（一）]]></title>
        <id>https://singledigit9.github.io/post/cshi-pin-xue-xi-bi-ji-yi/</id>
        <link href="https://singledigit9.github.io/post/cshi-pin-xue-xi-bi-ji-yi/">
        </link>
        <updated>2020-07-15T18:03:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="视频1为什么要学c">视频1：为什么要学C++</h1>
<ol>
<li>高效（在代码不烂的基础上）</li>
<li>能够控制底层硬件</li>
<li>任意平台支持</li>
<li>能够控制CPU执行的任意一条指令</li>
</ol>
<h1 id="视频234c编程环境配置">视频2，3，4：C++编程环境配置</h1>
<p>C++编程环境配置以及Hello World</p>
<h1 id="视频5c如何工作的">视频5：C++如何工作的</h1>
<ol>
<li>流程：C++代码 =[编译]=》一个C++文件对应一个obj文件 =[链接器]=》exe，dll等等。</li>
<li>Build过程中注意Debug/Release设置和目标平台的设置。</li>
<li>不同平台的Debug/Release可以单独设置，注意打包时不要弄错。</li>
<li>默认Debug设置下，有个配置选项不是速度优先，所以一般Debug模式下代码都比较慢</li>
<li>看报错Log时不要只看提示，应该看完整的Log。那个提示只是在Log中抓取error关键字进行显示而已。</li>
<li>链接器会找不同文件中代码的各种引用定义，来确定各个文件代码中使用的时正确的引用。</li>
</ol>
<h1 id="视频6编译器如何工作">视频6：编译器如何工作</h1>
<ol>
<li>将文本文件转化为可执行文件需要两个步骤：编译和链接</li>
<li>编译器的主要工作就是将文本文件转化为Obj文件
<ol>
<li>预处理文件，执行预编译指令。（include只是简单的把别的文件的代码粘贴到当前的代码中）</li>
<li>标记解释【<strong>这个地方记不太清了需要重新看一下</strong>】</li>
<li>解析</li>
</ol>
</li>
<li>每一个Cpp文件都是一个编译单元。</li>
<li>C++不在乎文件，文件只是给编译器提供原始代码数据的一种方式，可以指定任意后缀的文件作为源代码文件。</li>
<li>编译单元不等于cpp文件，因为cpp文件中可能会相互相互include。【<strong>这一个部分需要进一步测试，理解不好</strong>】</li>
<li>可以设置配置，生成预处理后的代码文件（xxx.i）</li>
<li>可以配置，让生成的Obj改为其他的可读模式</li>
<li>Debug模式，编译器会插入许多代码来帮助Debug</li>
<li>Obj的可读模式中，函数名会编程一系列编码，因为程序需要各种函数是唯一的。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《暴雪的哈希算法》笔记]]></title>
        <id>https://singledigit9.github.io/post/lesslessbao-xue-de-ha-xi-suan-fa-greatergreater-bi-ji/</id>
        <link href="https://singledigit9.github.io/post/lesslessbao-xue-de-ha-xi-suan-fa-greatergreater-bi-ji/">
        </link>
        <updated>2020-06-30T14:48:24.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>今天看了《暴雪的哈希算法》这篇文章。<br>
虽然说哈希算法基本都是老生常谈，但文章中哈希的实现思路确实很巧妙，很值得借鉴。</p>
<h1 id="特别之处">特别之处</h1>
<p>相比于一般的哈希算法，计算一次哈希值，之后冲突时或者使用链表，或者下移。<br>
暴雪的哈希算法计算了三个哈希值，从概率上来看，两个字符串的三个哈希值都一样的概率非常非常低，可以忽略这种情况。<br>
至于查找时，通过依次比对字符串3个哈希值来确定当前哈希表中是不是有该值，效率更高。</p>
<h1 id="文章链接">文章链接</h1>
<p>https://www.cnblogs.com/duzouzhe/archive/2009/10/14/1583359.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《游戏编程模式》读书笔记 序章]]></title>
        <id>https://singledigit9.github.io/post/lesslessyou-xi-bian-cheng-mo-shi-greatergreater-du-shu-bi-ji-xu-zhang/</id>
        <link href="https://singledigit9.github.io/post/lesslessyou-xi-bian-cheng-mo-shi-greatergreater-du-shu-bi-ji-xu-zhang/">
        </link>
        <updated>2020-06-27T14:36:50.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="写在前面">写在前面</h1>
<p>书的英文名是《Game Programming Patterns》，作者是Robert Nystrom。<br>
看了序章的内容，就觉得这本书和一般的设计模式书相比，更加贴近于游戏开发。而且序章中明确的指出了一些开发过程中可能遇到的问题。<br>
对于游戏开发的帮助很大。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1>
<p>书的英文名是《Game Programming Patterns》，作者是Robert Nystrom。<br>
看了序章的内容，就觉得这本书和一般的设计模式书相比，更加贴近于游戏开发。而且序章中明确的指出了一些开发过程中可能遇到的问题。<br>
对于游戏开发的帮助很大。</p>
<!-- more -->
<h1 id="游戏开发中常见的挑战">游戏开发中常见的挑战</h1>
<ol>
<li>时间和顺序。</li>
<li>高度压缩的开发周期，高速的版本迭代。需要程序能够快速迭代版本同时保证<strong>不干扰他人</strong>，<strong>不污染代码库</strong>。</li>
<li>实现互动不能把代码搞的一团糟。比如怪物攻击英雄，炸弹炸飞敌人之类的。</li>
<li>性能很重要。</li>
</ol>
<h1 id="怎么评价一个架构的好坏">怎么评价一个架构的好坏</h1>
<ol>
<li>架构是有关于改动的，没有改动的情况下谈架构毫无意义。</li>
<li>评价架构的好坏就是它对应改动有多么轻松。</li>
</ol>
<h1 id="解耦的根本目的是什么">解耦的根本目的是什么</h1>
<p>扩展新功能时，总是要把对应的模块代码熟悉好，知道什么地方是干什么的。<br>
解耦的作用就在于，<strong>最小化在编码前需要了解的信息</strong>。<br>
另一个常规的解耦的作用就是，当一块代码有改动时，没必要改动另一块代码。<strong>耦合度越小，改动所波及的外围就越小</strong>。</p>
<h1 id="架构的代价">架构的代价</h1>
<ol>
<li><strong>需要汗水和纪律来维持好的设计</strong>。需要每一次功能实现和改动都努力去保持架构原有的结构。</li>
<li><strong>需要管理代码</strong>。有无数优雅的开始，死于懒得动脑的“黑魔法”。</li>
</ol>
<h1 id="警惕过度设计">警惕过度设计</h1>
<p>当你在不怎么确定的功能实现的过程中，添加了抽象可扩展之类的支持，你是在赌需求和你预留的扩展一致。此外，抽象和扩展需要不断的进行维护。</p>
<p>当你过分关注抽象和扩展之类的东西，你写的代码就失控了——抽象和接口无处不在——最终可能你自己都不知道实现这个功能需要用什么接口，也有可能出现一个莫名奇妙的Bug让你查上一整天。</p>
<h1 id="性能和速度">性能和速度</h1>
<p>架构使代码变得灵活，灵活性让我们能够更快速的改进游戏，高速迭代。但也可能会加大运行时的开销。</p>
<p>性能与假设相关，<strong>确定性能优化方案需要有明确的需求限制</strong>。在需求不明确的情况下，你做的优化很有可能是无效优化甚至是负面优化（出了Bug或者不能满足功能）。</p>
<p>一种折中的方案就是保持代码灵活性，直到确定设计，再去除多余抽象等来提高性能。</p>
<h1 id="关于速度的权衡">关于速度的权衡</h1>
<p>长期开发速度，游戏运行速度，短期开发速度。这三者基本上是相互对立的，没有正确的方案，只有当前下的最优解。这个最优解取决于很多放面的因素，包括团队风格，领导风格，工作流程等等。</p>
<h1 id="简单">简单</h1>
<p>这个简单指的就是你的代码要尽可能的简单，让人能够简单明了的知道你写的每一个函数，每一个类都是干什么的。<br>
最最直观的就是代码量要尽可能的小，该有注释的地方不要省注释。</p>
<p>代码简单少，意味着写新功能需要提前读的代码少，查Bug读的代码也少，也因为代码少能避免很多不必要的Bug。</p>
<p><em>曾经在开发过程中遇到过这样的代码，他把数据类中的数据在自己功能实现的地方做了多次额外缓存， 最终导致的后果就是，数据更新的地方出了Bug，各种缓存数据需有的需要立即更新，有的需要延迟更新，代码乱到基本无法维护，只能重写。</em></p>
<h1 id="最后的建议">最后的建议</h1>
<ol>
<li>抽象和解耦让代码更容扩展，但除非确认需要灵活性，否则不用在这个上面浪费时间。</li>
<li>整个开发过程中确实需要考虑设计，但要避免针对底层的大面积优化。因为这样做会锁死代码，导致自己或者其他人无法进行正常的开发流程。</li>
<li>确定要被抛弃的代码用不着搞的尽善尽美。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SimpleFramework的相关文档]]></title>
        <id>https://singledigit9.github.io/post/simpleframework-de-xiang-guan-wen-dang/</id>
        <link href="https://singledigit9.github.io/post/simpleframework-de-xiang-guan-wen-dang/">
        </link>
        <updated>2020-06-06T09:37:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>这个框架算是为了总结自己所掌握的东西的一个总结。目标是基于Unity和FairyGUI，完成一个轻量的方便使用的游戏框架。<br>
目前完成了一部分，还有不少内容需要填充和测试，空闲时间一点一点来做吧。</p>
<h2 id="碎碎念">碎碎念</h2>
<p>其实之前自己也写过一些半残的东西，不过很多都不成体系，模块不全。此外也是深感自己在技术学习上有种<strong>N乘50%<strong>的感觉，想总体回顾一下，把欠缺的东西补到</strong>100%</strong>。<br>
这个文档主要是记录自己已经完成了什么，完成的部分该怎么使用。以及还没有完成什么，已经完成的部分有哪些优化空间；以及一些临时想到的可以做的编辑器工具等等。<br>
希望今年年底能够完成所有主体功能，且都测试过，也就是传说中的1.0版本。</p>
<h1 id="已完成测试">已完成测试</h1>
<h2 id="对象池">对象池</h2>
<h2 id="状态机">状态机</h2>
<h2 id="事件系统">事件系统</h2>
<h2 id="调试工具部分">调试工具[部分]</h2>
<h3 id="有log输出工具">有Log输出工具</h3>
<h3 id="输出运行时间类">输出运行时间类</h3>
<h1 id="完成未测试">完成未测试</h1>
<h2 id="配置表">配置表</h2>
<ol>
<li>数据读取存储[完成]</li>
<li>自动生成代码[完成]</li>
<li>生成序列化数据[完成]</li>
<li>生成代码序列化数据配置工具[完成]</li>
<li>PC/Android/Ios各个平台测试[未完成]</li>
<li>测试[未完成]</li>
</ol>
<h1 id="进行中">进行中</h1>
<h2 id="ui">UI</h2>
<ol>
<li>界面生命周期[部分]
<ol>
<li>初始化</li>
<li>enter动画</li>
<li>显示界面</li>
<li>exit动画</li>
<li>隐藏界面</li>
<li>销毁界面</li>
</ol>
</li>
<li>界面切换缓存策略[未完成]</li>
<li>红点系统[部分]</li>
<li>强制引导系统[未完成]</li>
</ol>
<h2 id="assetbundle">AssetBundle</h2>
<ol>
<li>打AssetBundle工具[部分]
<ol>
<li>选定哪些资源打到哪个Bundle里面</li>
<li>Bundle的一些配置</li>
</ol>
</li>
<li>依赖查询工具[部分]</li>
<li>生成AssetBundle的加密和解密[未]</li>
</ol>
<h2 id="资源加载">资源加载</h2>
<ol>
<li>AssetBundle加载[未]
<ol>
<li>LZMA压缩模式</li>
<li>LZ4和未压缩模式</li>
</ol>
</li>
<li>Resources加载[未]</li>
<li>编辑器下模拟AssetBundle加载[未]</li>
<li>冗余缓存的清理[未]</li>
</ol>
<p>#未开始</p>
<h2 id="启动流程">启动流程</h2>
<h2 id="网络部分">网络部分</h2>
<ol>
<li>HTTP连接</li>
<li>TCP连接</li>
<li>UDP连接</li>
</ol>
<h2 id="本地数据保存加载">本地数据保存加载</h2>
<h2 id="本地化">本地化</h2>
<h2 id="常用的shader效果">常用的Shader效果</h2>
<h2 id="其他插件工具">其他插件工具</h2>
<ol>
<li>摇杆（这个应该有插件，找个好用的集成进来）</li>
</ol>
<h2 id="其他编辑器工具这部分工具随时想到随时添加">其他编辑器工具（这部分工具随时想到随时添加）</h2>
<ol>
<li>噪声图生成工具</li>
<li>渐变采样图生成工具</li>
<li>随机地形生成工具</li>
<li>随机地牢生成工具</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[表面着色器中的结构体]]></title>
        <id>https://singledigit9.github.io/post/biao-mian-zhao-se-qi-zhong-de-jie-gou-ti/</id>
        <link href="https://singledigit9.github.io/post/biao-mian-zhao-se-qi-zhong-de-jie-gou-ti/">
        </link>
        <updated>2020-05-30T14:27:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="input">Input</h1>
<figure data-type="image" tabindex="1"><img src="https://singledigit9.github.io/post-images/1590848930611.jpeg" alt="" loading="lazy"></figure>
<h1 id="surfaceoutput">SurfaceOutPut</h1>
<p><img src="https://singledigit9.github.io/post-images/1590849021066.jpeg" alt="" loading="lazy"><br>
<img src="https://singledigit9.github.io/post-images/1590849027972.jpeg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Unity Shader 入门精要》读书笔记（扩展篇）]]></title>
        <id>https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-kuo-zhan-pian/</id>
        <link href="https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-kuo-zhan-pian/">
        </link>
        <updated>2020-05-19T18:18:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第17章-unity表面着色器探秘">第17章 Unity表面着色器探秘</h1>
<ol>
<li>表面着色器，实际上是Unity在基本的顶点片元着色器上进行的一次封装。在实际运行过程中，会自动转换成对应的顶点片元着色器来运行。</li>
<li>表面着色器的好处在于，可以方便的处理光照等效果。相同的光照效果用表面着色器实现，需要写的代码会比顶点片元着色器少好多。但它的缺点在于，一是自由度受到一些限制，有些特殊效果表面着色器实现不了；二是性能消耗一般都比较大。</li>
<li>表面着色器的计算步骤
<ol>
<li>将CGPROGRAM和ENDCG中的代码进行复制</li>
<li>生成顶点着色器输出结构体v2f_surf，用于顶点着色器和片元着色器之间数据传递。</li>
<li>生成顶点着色器。</li>
<li>生成片元着色器。</li>
<li>颜色叠加。</li>
<li>最后的颜色修改函数。<br>
<img src="https://singledigit9.github.io/post-images/1590849115208.jpeg" alt="" loading="lazy"></li>
</ol>
</li>
</ol>
<h1 id="第18章-基于物理的渲染">第18章 基于物理的渲染</h1>
<ol>
<li>Unity的Standard是金属工作流，Specularsetup是高光反射工作流。两种Shader都能调出相同的效果，只是有些参数不一样。</li>
<li>伽马校正：
<ol>
<li>原理是人们对明亮部分的光线变化的敏感程度远远低于暗的部分的敏感程度。比如，一个房间开一盏灯到开两盏灯和开99盏灯到开100盏灯给人的感觉是不同的。</li>
<li>伽马矫正是为了更加充分的利用图像的存储空间，将不明显的明亮部分压缩，将变化明显的暗的部分放大以存储更精细的值。</li>
<li>伽马校正下，显示整体偏暗。</li>
</ol>
</li>
<li>PBS（基于物理的渲染）优点在于，相当大的一部分物体，可以使用同一套shader来进行渲染，而且不用各种调参。缺点在于使用起来比较复杂，而且消耗来说也比较高。</li>
</ol>
<h1 id="第19章-unity5更新了什么">第19章 Unity5更新了什么</h1>
<p>现在版本都2019了，这章好多东西应该都不适用了，更详细的应该查unity的更新文档了。但还是简单记录一下，万一遇到类似的问题能够快速反应过来。</p>
<ol>
<li>表面着色器报错。
<ol>
<li>通常是因为转换着色器时使用了一些额外的效果计算，比如法线，光照之类的。从而导致需求的寄存器数目超过限定的寄存器数目。</li>
<li>解决办法
<ol>
<li>可以将默认的Shader Model 2.0 改为3.0，即<code>#pragma target 3.0</code>。</li>
<li>可以手动设置该着色器不计算阴影纹理坐标（不接受阴影），不计算光照纹理和雾效 ，减少额外计算。即<code>#pragma surface surfaceFunction lightModeln oshadow nolightmap nofog</code></li>
</ol>
</li>
</ol>
</li>
<li>CPU不再处理非统一缩放，也就是说，CPU会把顶点信息和非统一缩放的矩阵直接传给Shader。因此在顶点片元着色器中变换顶点法线时，需要注意非统一缩放的影响，也要注意对变换后的法线进行手动归一化操作。</li>
<li>固定管线Shader被放弃。</li>
</ol>
<h1 id="第20章-还有更多内容么">第20章 还有更多内容么</h1>
<ol>
<li>OpenGL
<ol>
<li>红宝书：《OpenGL编程指南》</li>
<li>蓝宝书：《OpenGL超级宝典》</li>
</ol>
</li>
<li>GPU精粹系列</li>
<li>叶劲峰 ，计算机图形：入门/API类；Gems类</li>
<li>GPU Pro系列和ShaderX系列</li>
<li>物理渲染和光线追踪：《Physically based rendering : From theory to implementation》</li>
<li>学术会议（Ke-Sen Huang主页上有历年的论文）
<ol>
<li>SIGGRAPH</li>
<li>SIGGRAPH Asia</li>
<li>Eurographics</li>
<li>Symposium On Interactive 3D Graphics And Games</li>
</ol>
</li>
<li>Shadertoy网站</li>
<li>GLSL SandBox Gallery网站</li>
</ol>
<h1 id="后记">后记</h1>
<p>算是终于完整看完了一遍吧。感觉自己对着色器这块确实了解的更加深入了。有一些以前一知半解的东西知道是怎么回事了。比如说伽马空间之类的。<br>
此外就是觉得自己做的练习还是比较少，而且仅仅是记笔记的话也不是很方便以后自己翻笔记查阅。因此准备在gitbook上专门弄一个shader的资料库。算是复习和继续深入学习兼而有之吧。<br>
预备Shader资料库的大致结构分为基础知识部分，数学部分，算法公式部分，代码块部分，各种常见效果和自我研究的效果的实例部分。<br>
内容很多，希望能够在今年内把基本的内容填充完毕吧。<br>
也希望资料库完成后能给自己和其他需要的同学提供帮助。<br>
--2020.05.30 23:13</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《Unity Shader入门精要》读书笔记（高级篇）]]></title>
        <id>https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-gao-ji-pian/</id>
        <link href="https://singledigit9.github.io/post/lesslessunity-shader-ru-men-jing-yao-greatergreater-du-shu-bi-ji-gao-ji-pian/">
        </link>
        <updated>2020-05-16T15:22:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第12章-屏幕后处理效果">第12章 屏幕后处理效果</h1>
<h2 id="脚本api">脚本API</h2>
<ol>
<li>相机脚本中使用的API</li>
</ol>
<pre><code class="language-c_sharp">Monobehavior.OnRenderImage(RenderTexture src, RenderTexture dest){}

Graphics.Blit(Texture src, RenderTexture dest);
Graphics.Blit(Texture src, RenderTexture dest,  Material mat, int pass =  -1);
Graphics.Blit(Texture src, Material mat, int pass = -1);
</code></pre>
<ol start="2">
<li>参数说明
<ol>
<li>src：源纹理</li>
<li>mat：使用的材质</li>
<li>dest：目标渲染纹理。为Null则直接将结果显示在屏幕上</li>
<li>pass：默认-1，表示会依次执行Shader中所有的Pass，否则只执行指定索引的Pass</li>
</ol>
</li>
<li><code>ImageEffectOpaque</code>：可以控制OnRenderImage执行的位置。比如当只想后处理不透明物体时，设置这个属性，使OnRenderIamge在不透明物体渲染完毕后立即调用。</li>
</ol>
<h2 id="应用">应用</h2>
<ul>
<li>屏幕后处理的标配 <code>ZTest Always Cull Off ZWrite Off</code></li>
</ul>
<h3 id="调节屏幕亮度饱和度和对比度">调节屏幕亮度，饱和度和对比度</h3>
<ol>
<li>亮度：颜色 * 亮度值</li>
<li>饱和度：</li>
</ol>
<pre><code class="language-shader">fixed4 color = tex2D(_MainTex, i.uv)
fixed temp = 0.2125 * color.r + 0.7154 * color.g + 0.0721  * color.b;
fixed tempColor = fixed(temp, temp, temp);
color = fixed4(lerp(tempColor, color.rgb, 饱和度值), color.a);
</code></pre>
<ol start="3">
<li>对比度：</li>
</ol>
<pre><code class="language-shader">color = (lerp(fixed3(0.5, 0.5, 0.5), color.rgb, 对比度值), color.a);
</code></pre>
<h3 id="边缘检测">边缘检测</h3>
<ol>
<li>常见的边缘检测算子<br>
<img src="https://singledigit9.github.io/post-images/1589705801787.jpeg" alt="" loading="lazy"></li>
<li>梯度计算
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><msqrt><mrow><msubsup><mi>G</mi><mi>x</mi><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>G</mi><mi>y</mi><mn>2</mn></msubsup></mrow></msqrt></mrow><annotation encoding="application/x-tex">G=\sqrt{G_x^2 + G_y^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.84em;vertical-align:-0.6765000000000001em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1635em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7401079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.1235em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.8800000000000001em;"><svg width='400em' height='1.8800000000000001em' viewBox='0 0 400000 1944' preserveAspectRatio='xMinYMin slice'><path d='M1001,80H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,
572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,
-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39
c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60
s208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,
-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5c4,-6.7,10,-10,18,-10z
M1001 80H400000v40H1013z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6765000000000001em;"><span></span></span></span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><mi mathvariant="normal">∣</mi><msub><mi>G</mi><mi>x</mi></msub><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><msub><mi>G</mi><mi>y</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">G = |G_x| + |G_y|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span></li>
</ol>
</li>
</ol>
<h3 id="高斯模糊">高斯模糊</h3>
<ol>
<li>高斯模糊卷积核<br>
<img src="https://singledigit9.github.io/post-images/1589706552526.jpeg" alt="" loading="lazy"></li>
<li><code>RenderTexture.GetTemporary</code>：获取一个缓存RenderTexture</li>
<li><code>RenderTexture.ReleaseTemporary</code>：释放缓存RenderTexture</li>
</ol>
<h3 id="bloom效果">Bloom效果</h3>
<ol>
<li>原理：根据阈值提取出较亮的区域，存在一个RenderTexture中，然后对它进行模糊，模拟光线扩散。最后将RenderTexture与原图向混合。</li>
<li>阈值提取</li>
</ol>
<pre><code class="language-shader">fixed luminance(fixed4 color) {
    return  0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b; 
}

fixed4 fragExtractBright(v2f i) : SV_Target {
    fixed4 c = tex2D(_MainTex, i.uv);
    fixed val = clamp(luminance(c) - _LuminanceThreshold, 0.0, 1.0);
    
    return c * val;
}
</code></pre>
<h3 id="运动模糊">运动模糊</h3>
<ol>
<li><code>RenderTexture.MarkRestoreExpected</code>：标记这个RenderTexture需要还原操作，避免Unity警告。</li>
<li>原理：
<ol>
<li>将多个图像进行叠加</li>
<li>使用速度缓存，根据速度来决定模糊采样的大小和方向</li>
</ol>
</li>
<li>书中使用的方法是在同一个RenderTexture上叠加图像来实现的。但速度过快时，会明显看到单帧的图像。</li>
</ol>
<h1 id="第13章-使用深度和法线纹理">第13章 使用深度和法线纹理</h1>
<ol>
<li>深度纹理本质上是一张渲染纹理，它存储的是深度值而不是颜色值。范围是 [0, 1]</li>
<li>深度值和NDC空间z坐标对应关系：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>=</mo><msub><mi>z</mi><mrow><mi>n</mi><mi>d</mi><mi>c</mi></mrow></msub><mo>∗</mo><mn>0.5</mn><mo>+</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">d =  z_{ndc} *  0.5 +  0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span></span></li>
<li>Unity得到深度纹理的流程
<ol>
<li>延迟渲染路径时，因为延迟渲染会把深度信息法线信息渲染都G-Buffer中，所以深度纹理和能够直接冲G-Buffer中获取，深度法线纹理一样简单合并一下就可以得到。</li>
<li>无法直接获取时，深度和法线纹理是通过单独的Pass来渲染获取的。Unity会使用<strong>着色器替换</strong>技术来选择那些渲染类型为<code>Opaque</code>的物体，判断它们的渲染队列是不是小于2500（包含BackGround，Geometry，AlphaTest），如果满足条件，则建起渲染到深度纹理中。因此，要想获得争取的深度纹理，就需要设置正确的<code>RenderType</code>。
<ol>
<li>Unity调用ShadowCaster的Pass来渲染深度纹理，因此，如果物体的Shader中不包含这个Pass，，那么这个物体就不会出现在深度纹理中。</li>
<li>Unity可以设置只渲染深度纹理还是渲染深度法线纹理。</li>
<li>因为前向渲染默认不创建深度缓存，所以Unity底层使用了额外的Pass来额外渲染。这个Pass在<code>/DefaultResources/Camera-DepthNormalTexture.shader</code>中。</li>
</ol>
</li>
</ol>
</li>
<li>深度纹理通常是24位或者16位。深度法线纹理通常是32位，其中法线存储在RG中，深度存储在BA中。</li>
<li>具体的获取
<ol>
<li>C#脚本中的API：<code>camera.depthTextureMode</code></li>
<li>Shader中声明的贴图：<code>_CameraDepthTexture</code>和<code>_CameraDepthNormalTexture</code>。</li>
<li>Shader中的采样
<ol>
<li>一般来说直接用tex2D就可以，但可能某些平台会不适用。</li>
<li>使用Unity内置的宏<code>float d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i,uv);</code></li>
<li>类似的还有<code>float d = SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(i.scrPos))</code>
<ol>
<li>第二个参数通常是由顶点着色器输出插值而得到的屏幕坐标。<code>i.scrPos = ComputeScreenPos(o.pos)</code></li>
<li>采样计算过程，使用前两个分量除以最后一个分量。</li>
</ol>
</li>
<li><code>DecodeDepthNormal(float4 depthNormalTexColor, out float depth, out float3 normal)</code>
<ol>
<li>需要注意返回的法线是视角空间下的法线方向。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>运动模糊
<ol>
<li>使用速度映射。通过深度纹理为每个像素计算其世界空间下的位置。并与前一帧的位置做差值，从而得到速度。好处是能够在一个屏幕后处理中完成整个效果，缺点就是性能消耗比较大。</li>
</ol>
</li>
<li>雾效
<ol>
<li>公式：<code>float3 afterFog = f * fogColor + (1 - f) * origColor</code>
<ol>
<li>雾效系数<code>f</code>的计算公式
<ol>
<li>线性：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>=</mo><mo>(</mo><msub><mi>d</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><mi mathvariant="normal">∣</mi><mi>z</mi><mi mathvariant="normal">∣</mi><mo>)</mo><mi mathvariant="normal">/</mi><mo>(</mo><mrow><msub><mi>d</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>−</mo><msub><mi>d</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">f = (d_{max} - |z|)/({d_{max} - d_{min}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord">∣</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>指数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>d</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>z</mi><mi mathvariant="normal">∣</mi></mrow></msup></mrow><annotation encoding="application/x-tex">f = e^{-d*|z|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">d</span><span class="mbin mtight">∗</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mord mtight">∣</span></span></span></span></span></span></span></span></span></span></span></span></li>
<li>指数平方：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mo>(</mo><mi>d</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>z</mi><mi mathvariant="normal">∣</mi><msup><mo>)</mo><mn>2</mn></msup></mrow></msup></mrow><annotation encoding="application/x-tex">f = e^{-(d*|z|)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9869199999999998em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999998em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">d</span><span class="mbin mtight">∗</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mord mtight">∣</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="第14章-非真实感渲染">第14章 非真实感渲染</h1>
<h2 id="卡通风格渲染">卡通风格渲染</h2>
<h3 id="轮廓线">轮廓线</h3>
<ol>
<li>基于观察角度和法线：简单快速，但局限性很大，描边效果不好。</li>
<li>使用两个Pass，一个渲染背面，一个渲染正面。背面用纯色渲染稍微大一圈，组合到一起就是描边效果了。但这种方式仅仅适用于轮廓平滑的模型，不适用于立方体这类的模型。</li>
<li>基于图像处理的轮廓线渲染。使用算子进行边缘检测。适用范围广，效果较好。但一些深度法线变化小的轮廓可能无法检测出来。</li>
<li>基于轮廓边检测的轮廓线检测。原理是检测相邻的两个三角面的朝向是否不一致（是不是一个朝前一个朝后），如果不一致则两个三角面之间有一条轮廓线。但这种方式也有缺点，一个是实现复杂，另一个是动画在帧与帧之间不连贯。
<ol>
<li>公式：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>n</mi><mn>0</mn></msub><mo separator="true">⋅</mo><mi>v</mi><mo>&gt;</mo><mn>0</mn><mo>)</mo><mo>!</mo><mo>=</mo><mo>(</mo><msub><mi>n</mi><mn>1</mn></msub><mo separator="true">⋅</mo><mi>v</mi><mo>&gt;</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(n_0 · v &gt; 0) != (n_1 · v &gt; 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></li>
</ol>
</li>
</ol>
<h3 id="高光">高光</h3>
<p>卡通的高光相比于一般的高光来说，颜色过度更贱&quot;生硬&quot;。因此我们将普通的高光公式所求的的值，与一个阈值进行比较，小于该阈值直接为0，大于该阈值直接为1.</p>
<h2 id="素描风格渲染">素描风格渲染</h2>
<ol>
<li>使用了色调艺术映射的技术。</li>
<li>根据观察方向和法线的点积值，if判断，来确定使用那个贴图的素材。从而叠加渲染。</li>
</ol>
<h1 id="第15章-使用噪声">第15章 使用噪声</h1>
<ol>
<li>消融效果：在噪声图上采样，得到噪声值。然后将当前颜色值与噪声值进行比较，大于或者小于的直接将该片元discard。剩余的片元再次处理一下边缘颜色就可以了。</li>
<li>水波效果：基于时间，在法线噪声图上采样。用采样得到的法线值，计算颜色偏移等。</li>
<li>烟雾飘动的效果。</li>
</ol>
<h1 id="第16章-unity中的渲染优化技术">第16章 Unity中的渲染优化技术</h1>
<p>首要规则：过度优化和不优化一样严重。</p>
<p>此外有一篇关于Unity优化的导图文章特别好，写的很全。基本上按照那个导图一个流程走下来，性能应该没什么大问题。但因为那个导图是收费的，这里不好直接贴上来。放一个链接，有兴趣可以去查看。</p>
<p><a href="https://mm.edrawsoft.cn/store">在线思维导图(在搜索里搜Unity就能找到了)</a></p>
<h2 id="移动平台的特点">移动平台的特点</h2>
<ol>
<li>移动设备一般使用基于Tile的延迟渲染架构，即将图像装入一个个tile中。然后再由硬件选择将tile中的哪个图像渲染到屏幕上。</li>
<li>基于上面描述的渲染架构的特点，overDraw（就是一个像素被多次绘制）很有可能是性能瓶颈。</li>
</ol>
<h2 id="影响性能的因素">影响性能的因素</h2>
<ol>
<li>CPU
<ol>
<li>draw Call</li>
<li>逻辑</li>
<li>物理</li>
</ol>
</li>
<li>GPU
<ol>
<li>顶点
<ol>
<li>顶点过多</li>
<li>顶点计算过多</li>
</ol>
</li>
<li>片元
<ol>
<li>过多的片元</li>
<li>逐片元计算过多</li>
</ol>
</li>
</ol>
</li>
<li>带宽
<ol>
<li>尺寸过大的未压缩的纹理</li>
<li>分辨率过高的帧缓存</li>
</ol>
</li>
</ol>
<h2 id="unity中的分析工具">Unity中的分析工具</h2>
<ol>
<li>
<p>渲染统计信息。Game窗口的Stats<br>
<img src="https://singledigit9.github.io/post-images/1590816549696.jpeg" alt="" loading="lazy"><br>
<img src="https://singledigit9.github.io/post-images/1590816560024.jpeg" alt="" loading="lazy"></p>
</li>
<li>
<p>Profiler<br>
可以动态查看当前帧的消耗情况。但需要注意的是，编辑器下的调试有一定的参考价值，但和真机上还是有差别。</p>
</li>
<li>
<p>帧调试器<br>
可以看每一帧都渲染了什么东西，有什么东西是应该一起渲染的但是没有一起渲染（这个对FairyGUI尤其有用。优化时FairyGUI往往调整一下层级就会减少一些DrawCall）</p>
</li>
</ol>
<h2 id="动态批处理">动态批处理</h2>
<ol>
<li>顶点数小于900。如果Shader中使用了顶点位置，法线，纹理坐标这3个顶点属性，那么就要小于300</li>
<li>同一个缩放尺度下。（书上说Unity5之后已经对这个进行了优化，但我在Unity2018下用Cube进行试验，不同缩放尺度的Cube一样会增加DrawCall，想动态批处理的话，这个最好还是严格遵守）</li>
<li>需要动态批处理的物体应该指向光照纹理的同一个位置。（<strong>光照纹理这部分接触较少，需要深入学习</strong>）</li>
<li>多Pass的Shader会中断批处理操作。</li>
</ol>
<h2 id="静态批处理">静态批处理</h2>
<p>运行开始阶段，将需要静态批处理的网格合并到一个大网格中。<br>
静态批处理相比于动态批处理更加高效，但仍然有一些缺点。</p>
<ol>
<li>静态批处理的物体不能够移动</li>
<li>往往会占用更多的内存。因为一些物体如果共享了相同的网格，合并前每一个物体都会有一个该网格的复制。最终导致一个网格的多个复制会发给GPU，从而导致性能瓶颈。
<ol>
<li>例子：1000个相同模型的树，如果使用了静态批处理，则会吧这个模型的1000的复制合并到一个大网格里进行处理。也就是说，一个树的模型，我们多消耗了999个单位的内存空间。</li>
</ol>
</li>
</ol>
<h2 id="共享材质">共享材质</h2>
<p>关键字：shareMaterial</p>
<ol>
<li>使用Renderer.Material时，会创建一份原始材质球的复制，造成额外消耗。</li>
<li>使用Renderer.ShareMaterial时，会修改原始的材质球，从而使使用这个材质球的模型都收到影响。</li>
</ol>
<h2 id="减少顶点">减少顶点</h2>
<ol>
<li>模型制作，去除不必要的顶点和边</li>
<li>LOD</li>
<li>遮挡剔除技术（<strong>这个需要重点学习一下，之前没有用过。</strong>）</li>
</ol>
<h2 id="减少片元">减少片元</h2>
<ol>
<li>减少overDraw
<ol>
<li>最最主要的，尽可能不要用半透明的渲染队列。半透明物体会破坏渲染队列。</li>
<li>对于UI，如果无法避免半透明，可以将UI的相机和其他的场景相机分开，不要一起渲染。</li>
<li>透明度测试也会影响游戏性能。discard和clip操作可能会导致一些硬件的优化策略失败。</li>
</ol>
</li>
<li>减少实时光照和阴影
<ol>
<li>灯光贴图</li>
<li>移动平台上，物体的逐像素光照光源数目应该小于1（不包括平行光）。如果为了效果需要多个光源，请使用逐顶点光照。</li>
<li>将光照计算存储到纹理中。根据光源方向，视角方向，法线方向等直接从纹理采样得到信息。但这种方法需要编写对应的美术编辑器，</li>
</ol>
</li>
</ol>
<h2 id="较少带宽">较少带宽</h2>
<ol>
<li>减少纹理大小。纹理大小应该是2的整数次幂。纹理压缩格式在不影响效果的情况下，应该压缩到最小。</li>
<li>有些设备空有高分辨率的屏幕而没有配套的其他硬件，从而导致游戏在那个设备上运行时效果不好。可以使用Screen.SetResolution来设置分辨率。（<strong>这块需要进一步查阅资料学习</strong>）</li>
</ol>
<h2 id="减少计算复杂度">减少计算复杂度</h2>
<ol>
<li>Shader中的LOD
<ol>
<li>只有Shader中的LOD小于指定值时，这个Shader才会被使用。</li>
<li>内置的Diffuse的LOD是200，BumpedSpecular是400。</li>
</ol>
</li>
<li>Shader代码
<ol>
<li>计算数目排序：物体数量 &lt; 顶点数量 &lt; 片元数量</li>
<li>尽可能把计算上移，减少计算。</li>
<li>尽可能使用低精度浮点数进行计算</li>
<li>避免不同精度数来回切换</li>
<li>避免频繁的color.rgrg操作</li>
<li>尽可能不要用屏幕后处理</li>
<li>如果需要使用屏幕后处理，尽可能把多个特效封到一个Shader里</li>
<li>尽可能不要用分支和循环，sin, tan, pow，等费时操作，以及discard操作。</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
</feed>